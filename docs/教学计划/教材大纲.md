# AI增强的软件工程 - 教材大纲（修订版v3）

## 教材信息

| 项目 | 内容 |
|------|------|
| **教材名称** | AI增强的软件工程 - 从架构设计到职业发展 |
| **适用对象** | 计算机科学与技术、软件工程专业本科生 |
| **参考学时** | 64学时（32理论 + 32实训） |
| **编写时间** | 2026-02-22 |
| **更新时间** | 2026-03-02 |
| **核心理念** | AI是增强工具，人类掌握核心思维和方法 |

---

## 教材核心理念

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        教材核心理念                                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   v3版本设计理念                                                             │
│   ────────────────                                                           │
│   上半学期：单一AI工具 + UML建模 + 快速原型（降低难度）                        │
│   下半学期：协同开发 + 工程治理 + 发布流程（提升能力）                          │
│                                                                              │
│   教学方法：What-Why-How                                                    │
│   ──────────────────────                                                     │
│   • What：概念是什么，定义和内涵                                             │
│   • Why：为什么需要，价值和意义                                              │
│   • How：如何实践，方法和工具                                                │
│                                                                              │
│   教学重点                                                                   │
│   ────────                                                                   │
│   • 理解软件工程的本质和发展历程                                             │
│   • 掌握UML建模和架构设计方法                                                │
│   • 掌握AI辅助开发的能力边界和使用方法                                       │
│   • 掌握软件治理和工程化实践                                                 │
│   • 了解职业发展路径和AI时代规划                                             │
│                                                                              │
│   项目载体：SQLRustGo                                                        │
│   ──────────────────                                                         │
│   数据库项目作为实践载体，让学生体验完整的软件开发生命周期，                   │
│   从项目经理到产品经理的知识结构和工作内容。                                  │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 教材结构

### 第一篇：软件工程基础与UML建模（第1-4章）

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        第一篇：软件工程基础与UML建模                          │
│                        （重点：建立工程思维和建模能力）                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   第1章：软件工程概述与项目导论                                              │
│   ├── 1.1 软件工程发展历史（What）                                           │
│   │   ├── 1.1.1 软件危机与软件工程的诞生                                    │
│   │   ├── 1.1.2 结构化编程时代（1968-1980）                                 │
│   │   ├── 1.1.3 面向对象时代（1980-2000）                                   │
│   │   ├── 1.1.4 敏捷与DevOps时代（2000-2020）                               │
│   │   └── 1.1.5 AI增强时代（2020-现在）                                     │
│   ├── 1.2 Greenfield与Brownfield项目（What）                                │
│   │   ├── 1.2.1 Greenfield项目：从零开始构建                                │
│   │   ├── 1.2.2 Brownfield项目：在现有系统上修改                            │
│   │   └── 1.2.3 项目类型对比与选择                                          │
│   ├── 1.3 AI对软件工程的影响（Why）                                         │
│   │   ├── 1.3.1 大语言模型的突破                                            │
│   │   ├── 1.3.2 AI-IDE工具演进                                              │
│   │   └── 1.3.3 AI Coding的局限性与适用范围                                 │
│   ├── 1.4 SQLRustGo项目导论（How）                                          │
│   │   ├── 1.4.1 项目背景和目标                                              │
│   │   ├── 1.4.2 项目版本历程概览                                            │
│   │   └── 1.4.3 课程安排说明                                                │
│   └── 1.5 本章小结与练习                                                     │
│                                                                              │
│   第2章：结构化设计与UML基础                                                │
│   ├── 2.1 结构化设计方法（What/Why/How）                                    │
│   │   ├── 2.1.1 历史背景                                                    │
│   │   ├── 2.1.2 核心思想：自顶向下、逐步求精                                │
│   │   ├── 2.1.3 模块化设计原则                                              │
│   │   └── 2.1.4 数据流图（DFD）                                             │
│   ├── 2.2 UML概述（What/Why/How）                                           │
│   │   ├── 2.2.1 UML的历史和发展                                             │
│   │   ├── 2.2.2 UML 2.0分类：结构图 vs 行为图                               │
│   │   └── 2.2.3 UML工具介绍：PlantUML                                       │
│   ├── 2.3 用例图（What/Why/How）                                            │
│   │   ├── 2.3.1 组成元素：参与者、用例、系统边界                            │
│   │   ├── 2.3.2 用例之间的关系                                              │
│   │   └── 2.3.3 实例：SQLRustGo用例图                                       │
│   └── 2.4 本章小结与练习                                                     │
│                                                                              │
│   第3章：面向对象设计与类图                                                  │
│   ├── 3.1 面向对象核心概念（What/Why/How）                                  │
│   │   ├── 3.1.1 封装、继承、多态                                            │
│   │   └── 3.1.2 面向对象设计原则                                            │
│   ├── 3.2 SOLID原则（What/Why/How）                                         │
│   │   ├── 3.2.1 单一职责原则（SRP）                                         │
│   │   ├── 3.2.2 开闭原则（OCP）                                             │
│   │   ├── 3.2.3 里氏替换原则（LSP）                                         │
│   │   ├── 3.2.4 接口隔离原则（ISP）                                         │
│   │   └── 3.2.5 依赖倒置原则（DIP）                                         │
│   ├── 3.3 类图（What/Why/How）                                              │
│   │   ├── 3.3.1 类的组成：类名、属性、方法                                  │
│   │   ├── 3.3.2 类之间的关系                                                │
│   │   └── 3.3.3 实例：SQLRustGo类图设计                                     │
│   └── 3.4 本章小结与练习                                                     │
│                                                                              │
│   第4章：顺序图、状态图与架构设计                                            │
│   ├── 4.1 顺序图（What/Why/How）                                            │
│   │   ├── 4.1.1 组成元素：对象、生命线、消息                                │
│   │   └── 4.1.2 实例：SQL查询执行顺序图                                     │
│   ├── 4.2 状态图（What/Why/How）                                            │
│   │   ├── 4.2.1 组成元素：状态、转换、事件                                  │
│   │   └── 4.2.2 实例：事务状态图                                            │
│   ├── 4.3 架构图与部署图（What/Why/How）                                    │
│   │   ├── 4.3.1 架构图类型                                                  │
│   │   └── 4.3.2 部署图设计                                                  │
│   ├── 4.4 快速原型法（What/Why/How）                                        │
│   │   ├── 4.4.1 原型类型：抛弃型 vs 演化型                                  │
│   │   ├── 4.4.2 原型法开发流程                                              │
│   │   └── 4.4.3 SQLRustGo草稿版本分析                                       │
│   └── 4.5 本章小结与练习                                                     │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 第二篇：架构设计与核心模块实现（第5-8章）

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        第二篇：架构设计与核心模块实现                          │
│                        （重点：架构思维和AI辅助开发）                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   第5章：架构设计原理与SQLRustGo架构                                         │
│   ├── 5.1 架构设计概述（What/Why/How）                                       │
│   │   ├── 5.1.1 什么是软件架构                                              │
│   │   ├── 5.1.2 为什么需要架构设计                                          │
│   │   └── 5.1.3 如何进行架构设计                                            │
│   ├── 5.2 SQLRustGo四层架构设计（What/Why/How）                             │
│   │   ├── 5.2.1 Parser Layer（解析层）                                      │
│   │   ├── 5.2.2 Planner Layer（规划层）                                     │
│   │   ├── 5.2.3 Executor Layer（执行层）                                    │
│   │   └── 5.2.4 Storage Layer（存储层）                                     │
│   ├── 5.3 架构图绘制实践                                                    │
│   │   ├── 5.3.1 使用PlantUML绘制架构图                                      │
│   │   └── 5.3.2 架构设计评审                                                │
│   ├── 5.4 AI辅助架构设计实践                                                │
│   │   ├── 5.4.1 使用AI生成架构方案                                          │
│   │   └── 5.4.2 使用AI生成架构图                                            │
│   └── 5.5 本章小结与练习                                                     │
│                                                                              │
│   第6章：功能模块划分与接口设计                                              │
│   ├── 6.1 功能模块划分（What/Why/How）                                       │
│   │   ├── 6.1.1 什么是功能模块                                              │
│   │   ├── 6.1.2 为什么需要功能模块划分                                      │
│   │   └── 6.1.3 如何进行功能模块划分                                        │
│   ├── 6.2 SQLRustGo功能模块划分（What/Why/How）                             │
│   │   ├── 6.2.1 Parser模块                                                  │
│   │   ├── 6.2.2 Planner模块                                                 │
│   │   ├── 6.2.3 Executor模块                                                │
│   │   ├── 6.2.4 Storage模块                                                 │
│   │   └── 6.2.5 Common模块                                                  │
│   ├── 6.3 接口设计原则与实践（What/Why/How）                                │
│   │   ├── 6.3.1 什么是接口设计                                              │
│   │   ├── 6.3.2 接口设计原则                                                │
│   │   └── 6.3.3 Rust接口设计实践                                            │
│   ├── 6.4 AI辅助接口设计实践                                                │
│   │   ├── 6.4.1 使用AI设计接口                                              │
│   │   └── 6.4.2 接口评审                                                    │
│   └── 6.5 本章小结与练习                                                     │
│                                                                              │
│   第7章：AI辅助核心模块实现                                                  │
│   ├── 7.1 AI辅助开发概述（What/Why/How）                                     │
│   │   ├── 7.1.1 AI辅助开发是什么                                            │
│   │   ├── 7.1.2 为什么使用AI辅助开发                                        │
│   │   └── 7.1.3 如何有效使用AI辅助开发                                      │
│   ├── 7.2 AI辅助实现词法分析器（What/Why/How）                              │
│   │   ├── 7.2.1 词法分析原理                                                │
│   │   ├── 7.2.2 使用AI生成Token定义                                         │
│   │   └── 7.2.3 使用AI生成词法分析器                                        │
│   ├── 7.3 AI辅助实现语法分析器（What/Why/How）                              │
│   │   ├── 7.3.1 语法分析原理                                                │
│   │   ├── 7.3.2 使用AI生成AST定义                                           │
│   │   └── 7.3.3 使用AI生成语法分析器                                        │
│   ├── 7.4 AI辅助实现存储引擎（What/Why/How）                                │
│   │   ├── 7.4.1 存储引擎原理                                                │
│   │   ├── 7.4.2 使用AI设计页结构                                            │
│   │   └── 7.4.3 使用AI实现缓冲池                                            │
│   └── 7.5 本章小结与练习                                                     │
│                                                                              │
│   第8章：测试驱动开发与Alpha版本                                             │
│   ├── 8.1 测试驱动开发（What/Why/How）                                       │
│   │   ├── 8.1.1 TDD的核心思想                                               │
│   │   ├── 8.1.2 Red-Green-Refactor循环                                      │
│   │   └── 8.1.3 TDD实践技巧                                                 │
│   ├── 8.2 AI辅助测试生成（What/Why/How）                                    │
│   │   ├── 8.2.1 使用AI生成测试用例                                          │
│   │   ├── 8.2.2 使用AI分析测试覆盖率                                        │
│   │   └── 8.2.3 实例：SQLRustGo测试                                         │
│   ├── 8.3 Rust测试框架                                                      │
│   │   ├── 8.3.1 #[test] 属性                                                │
│   │   ├── 8.3.2 assert! 宏系列                                              │
│   │   └── 8.3.3 测试覆盖率工具                                              │
│   ├── 8.4 Alpha版本验收                                                     │
│   │   ├── 8.4.1 Alpha版本定义                                               │
│   │   ├── 8.4.2 功能验收标准                                                │
│   │   ├── 8.4.3 质量门禁                                                    │
│   │   └── 8.4.4 Alpha版本发布                                               │
│   └── 8.5 本章小结与练习                                                     │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 第三篇：协同开发与工程治理（第9-12章）

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        第三篇：协同开发与工程治理                              │
│                        （重点：软件治理和工程化实践）                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   第9章：软件治理与分支策略                                                  │
│   ├── 9.1 软件治理概述（What/Why/How）                                       │
│   │   ├── 9.1.1 什么是软件治理                                              │
│   │   ├── 9.1.2 为什么需要软件治理                                          │
│   │   └── 9.1.3 如何实施软件治理                                            │
│   ├── 9.2 Git分支策略（What/Why/How）                                       │
│   │   ├── 9.2.1 什么是分支策略                                              │
│   │   ├── 9.2.2 常见分支策略                                                │
│   │   └── 9.2.3 SQLRustGo分支策略                                           │
│   ├── 9.3 分支保护与代码审核                                                │
│   │   ├── 9.3.1 分支保护规则                                                │
│   │   ├── 9.3.2 代码审核流程                                                │
│   │   └── 9.3.3 代码审核实践                                                │
│   └── 9.4 本章小结与练习                                                     │
│                                                                              │
│   第10章：PR工作流与项目成熟度评估                                           │
│   ├── 10.1 PR工作流详解（What/Why/How）                                      │
│   │   ├── 10.1.1 什么是PR工作流                                             │
│   │   ├── 10.1.2 为什么使用PR工作流                                         │
│   │   └── 10.1.3 PR工作流最佳实践                                           │
│   ├── 10.2 项目成熟度评估（What/Why/How）                                   │
│   │   ├── 10.2.1 什么是项目成熟度                                           │
│   │   ├── 10.2.2 成熟度等级                                                 │
│   │   └── 10.2.3 v2.0成熟度评估                                             │
│   ├── 10.3 v2.0功能规划                                                     │
│   │   ├── 10.3.1 JOIN支持                                                   │
│   │   ├── 10.3.2 子查询支持                                                 │
│   │   └── 10.3.3 视图支持                                                   │
│   └── 10.4 本章小结与练习                                                    │
│                                                                              │
│   第11章：CI/CD与OpenClaw自动化                                             │
│   ├── 11.1 CI/CD概述（What/Why/How）                                        │
│   │   ├── 11.1.1 什么是CI/CD                                                │
│   │   ├── 11.1.2 为什么需要CI/CD                                            │
│   │   └── 11.1.3 CI/CD流程设计                                              │
│   ├── 11.2 GitHub Actions实践（What/Why/How）                               │
│   │   ├── 11.2.1 GitHub Actions配置                                         │
│   │   ├── 11.2.2 为什么使用GitHub Actions                                   │
│   │   └── 11.2.3 SQLRustGo CI配置                                           │
│   ├── 11.3 OpenClaw多AI协作（What/Why/How）                                 │
│   │   ├── 11.3.1 什么是OpenClaw                                             │
│   │   ├── 11.3.2 为什么需要多AI协作                                         │
│   │   └── 11.3.3 AI角色分配与协作流程                                       │
│   └── 11.4 本章小结与练习                                                    │
│                                                                              │
│   第12章：性能优化与重构                                                    │
│   ├── 12.1 性能优化概述（What/Why/How）                                      │
│   │   ├── 12.1.1 什么是性能优化                                             │
│   │   ├── 12.1.2 为什么需要性能优化                                         │
│   │   └── 12.1.3 性能优化方法                                               │
│   ├── 12.2 性能分析方法（What/Why/How）                                     │
│   │   ├── 12.2.1 性能分析工具                                               │
│   │   ├── 12.2.2 为什么需要性能分析                                         │
│   │   └── 12.2.3 性能分析流程                                               │
│   ├── 12.3 代码重构（What/Why/How）                                         │
│   │   ├── 12.3.1 什么是代码重构                                             │
│   │   ├── 12.3.2 为什么需要重构                                             │
│   │   └── 12.3.3 重构方法                                                   │
│   ├── 12.4 SQLRustGo性能优化实践                                            │
│   │   ├── 12.4.1 查询优化                                                   │
│   │   ├── 12.4.2 缓存优化                                                   │
│   │   └── 12.4.3 并发优化                                                   │
│   └── 12.5 本章小结与练习                                                    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 第四篇：安全、发布与职业发展（第13-16章）

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        第四篇：安全、发布与职业发展                            │
│                        （重点：质量保证和职业规划）                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   第13章：安全扫描与审计                                                    │
│   ├── 13.1 软件安全概述（What/Why/How）                                      │
│   │   ├── 13.1.1 什么是软件安全                                             │
│   │   ├── 13.1.2 为什么需要安全扫描                                         │
│   │   └── 13.1.3 安全扫描方法                                               │
│   ├── 13.2 依赖扫描（What/Why/How）                                         │
│   │   ├── 13.2.1 什么是依赖扫描                                             │
│   │   ├── 13.2.2 为什么需要依赖扫描                                         │
│   │   └── 13.2.3 依赖扫描实践                                               │
│   ├── 13.3 代码扫描（What/Why/How）                                         │
│   │   ├── 13.3.1 什么是代码扫描                                             │
│   │   ├── 13.3.2 为什么需要代码扫描                                         │
│   │   └── 13.3.3 代码扫描实践                                               │
│   └── 13.4 本章小结与练习                                                    │
│                                                                              │
│   第14章：发布门禁与检查清单                                                │
│   ├── 14.1 发布门禁概述（What/Why/How）                                      │
│   │   ├── 14.1.1 什么是发布门禁                                             │
│   │   ├── 14.1.2 为什么需要发布门禁                                         │
│   │   └── 14.1.3 门禁配置                                                   │
│   ├── 14.2 门禁类型与配置（What/Why/How）                                   │
│   │   ├── 14.2.1 门禁类型详解                                               │
│   │   ├── 14.2.2 为什么需要多类型门禁                                       │
│   │   └── 14.2.3 门禁配置实践                                               │
│   ├── 14.3 RC版本验收（What/Why/How）                                       │
│   │   ├── 14.3.1 RC版本定义                                                 │
│   │   ├── 14.3.2 为什么需要RC版本验收                                       │
│   │   └── 14.3.3 RC门禁验收清单                                             │
│   └── 14.4 本章小结与练习                                                    │
│                                                                              │
│   第15章：版本发布与长期规划                                                │
│   ├── 15.1 版本发布流程（What/Why/How）                                      │
│   │   ├── 15.1.1 什么是版本发布                                             │
│   │   ├── 15.1.2 为什么需要规范的发布流程                                   │
│   │   └── 15.1.3 版本发布实践                                               │
│   ├── 15.2 版本号管理（What/Why/How）                                       │
│   │   ├── 15.2.1 语义化版本号                                               │
│   │   ├── 15.2.2 为什么需要语义化版本号                                     │
│   │   └── 15.2.3 版本号管理实践                                             │
│   ├── 15.3 长期功能规划（What/Why/How）                                     │
│   │   ├── 15.3.1 v3.0功能规划                                               │
│   │   ├── 15.3.2 v4.0功能规划                                               │
│   │   └── 15.3.3 v5.0功能规划                                               │
│   ├── 15.4 架构演化计划                                                     │
│   │   ├── 15.4.1 架构演化方向                                               │
│   │   ├── 15.4.2 技术债务管理                                               │
│   │   └── 15.4.3 团队能力建设                                               │
│   └── 15.5 本章小结与练习                                                    │
│                                                                              │
│   第16章：项目展示与职业发展                                                │
│   ├── 16.1 项目成果展示                                                     │
│   │   ├── 16.1.1 SQLRustGo项目回顾                                          │
│   │   ├── 16.1.2 功能演示                                                   │
│   │   ├── 16.1.3 性能演示                                                   │
│   │   └── 16.1.4 代码演示                                                   │
│   ├── 16.2 课程总结                                                         │
│   │   ├── 16.2.1 知识点回顾                                                 │
│   │   ├── 16.2.2 能力培养                                                   │
│   │   └── 16.2.3 课程收获                                                   │
│   ├── 16.3 职业发展路径                                                     │
│   │   ├── 16.3.1 软件工程师职业路径                                         │
│   │   ├── 16.3.2 技术专家路径                                               │
│   │   ├── 16.3.3 管理路径                                                   │
│   │   └── 16.3.4 AI时代职业规划                                             │
│   └── 16.4 课程结束语                                                        │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 附录

- **附录A**：UML图绘制指南（PlantUML语法）
- **附录B**：AI辅助开发提示词模板库
- **附录C**：Git命令与分支策略速查
- **附录D**：SQLRustGo项目参考
- **附录E**：职业发展路线图

---

## 教学重点对比

| 内容 | 传统教学重点 | AI增强教学重点（v3） |
|------|--------------|----------------------|
| 软件工程 | 理论知识 | What-Why-How方法论 |
| 架构设计 | 架构模式 | 架构思维和设计决策 |
| 模块划分 | 模块化原理 | 接口设计和依赖管理 |
| 编码 | 编程语法 | AI辅助开发能力边界 |
| 测试 | 测试方法 | TDD和AI辅助测试 |
| 协作 | 协作流程 | 软件治理和工程化 |
| 发布 | 发布流程 | 门禁设计和质量保证 |
| 职业 | 就业指导 | AI时代职业规划 |

---

**制定时间**: 2026-02-22  
**更新时间**: 2026-03-02  
**版本**: v3.0（采用What-Why-How教学法，加强架构设计和职业发展）
