# AI增强的软件工程 - 细化教学框架 v3

## 教学设计理念

### 核心思想

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        教学框架设计理念                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   上半学期（第1-8周）：AI辅助设计与快速原型                                    │
│   ══════════════════════════════════════════════                             │
│   • 单一AI工具（TRAE IDE）                                                   │
│   • UML建模分析与设计                                                        │
│   • 结构化设计与面向对象设计                                                  │
│   • 快速原型法实践                                                           │
│   • 项目草稿 → 架构设计 → 核心模块                                           │
│                                                                              │
│   下半学期（第9-16周）：协同开发与工程治理                                     │
│   ══════════════════════════════════════════════                             │
│   • 多AI协同工作流                                                           │
│   • Git分支控制、PR、合并流程                                                │
│   • Alpha → Beta → RC → Release 完整发布流程                                │
│   • 质量门禁与检查清单                                                       │
│   • 分布式开发思想与实践                                                     │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 项目版本历程与教学对应

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        SQLRustGo 项目版本历程                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   草稿 ──→ Alpha ──→ Beta ──→ RC1 ──→ Release/1.0 ──→ v2.0规划             │
│    │        │         │        │          │                                  │
│    ▼        ▼         ▼        ▼          ▼                                  │
│  快速原型  功能开发  质量提升  发布准备  正式发布                             │
│                                                                              │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │ 版本特征与教学对应                                                    │   │
│   ├─────────────────────────────────────────────────────────────────────┤   │
│   │                                                                      │   │
│   │ 草稿版本 (第1-4周教学):                                               │   │
│   │ • 项目实施计划                                                       │   │
│   │ • 核心类型系统设计                                                   │   │
│   │ • 词法/语法分析器原型                                                │   │
│   │ • 存储引擎基础结构                                                   │   │
│   │ 教学重点：UML建模、快速原型法、AI辅助设计                              │   │
│   │                                                                      │   │
│   │ Alpha版本 (第5-8周教学):                                              │   │
│   │ • 完整功能实现                                                       │   │
│   │ • 单元测试补充                                                       │   │
│   │ • 基础文档编写                                                       │   │
│   │ 教学重点：AI辅助编码、测试驱动开发、文档编写                           │   │
│   │                                                                      │   │
│   │ Beta版本 (第9-12周教学):                                              │   │
│   │ • 代码质量提升（unwrap移除、错误处理）                                │   │
│   │ • 用户文档完善                                                       │   │
│   │ • 安装程序制作                                                       │   │
│   │ • 测试计划制定                                                       │   │
│   │ 教学重点：代码审查、分支策略、PR流程                                  │   │
│   │                                                                      │   │
│   │ RC1版本 (第13-15周教学):                                              │   │
│   │ • 门禁检查清单                                                       │   │
│   │ • 安全扫描报告                                                       │   │
│   │ • CI/CD自动化                                                        │   │
│   │ • 发布验收                                                           │   │
│   │ 教学重点：质量门禁、CI/CD、安全审计                                   │   │
│   │                                                                      │   │
│   │ Release/1.0 (第16周教学):                                             │   │
│   │ • 正式发布                                                           │   │
│   │ • Release Notes                                                      │   │
│   │ • v2.0规划                                                           │   │
│   │ 教学重点：版本发布、项目演示、总结                                    │   │
│   │                                                                      │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 第一阶段：AI辅助设计与快速原型（第1-8周）

### 阶段目标

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    第一阶段目标：设计能力与原型开发                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   知识目标                                                                   │
│   ────────                                                                   │
│   • 理解软件工程发展历史和Greenfield/Brownfield项目                          │
│   • 掌握结构化设计和面向对象设计方法                                         │
│   • 掌握UML建模规范（用例图、类图、顺序图、状态图等）                         │
│   • 理解快速原型法的软件工程过程                                             │
│   • 理解AI Coding的能力边界和局限性                                          │
│                                                                              │
│   能力目标                                                                   │
│   ────────                                                                   │
│   • 能够使用UML进行系统分析和设计                                            │
│   • 能够使用AI工具辅助架构设计                                               │
│   • 能够使用AI工具实现核心模块                                               │
│   • 能够编写规范的测试用例                                                   │
│                                                                              │
│   产出目标                                                                   │
│   ────────                                                                   │
│   • 完成项目UML设计文档                                                      │
│   • 完成核心模块原型实现                                                     │
│   • 达到70%+测试覆盖率                                                       │
│   • 完成Alpha版本                                                            │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 详细教学计划

#### 第1周：软件工程概述与项目导论

**理论课（2学时）**：
```
Part 1: 软件工程发展历史（25分钟）
├── 软件工程的诞生（1968年NATO会议）
├── 发展阶段：结构化 → 面向对象 → 敏捷 → AI增强
├── 适用领域与成就
└── Greenfield vs Brownfield项目

Part 2: AI对软件工程的影响（25分钟）
├── 大语言模型（LLM）的突破
├── AI-IDE工具演进（Copilot → Cursor → Claude Code）
├── AI-CLI工具兴起
└── AI Coding的局限性与适用范围

Part 3: SQLRustGo项目导论（25分钟）
├── 项目背景和目标
├── 技术栈选择（Rust）
├── 项目版本历程概览
│   ├── 草稿 → Alpha → Beta → RC → Release
│   └── 每个版本的特征和产物
└── 作为Greenfield项目的典型案例

Part 4: 开发环境搭建（15分钟）
├── Rust 安装配置
├── TRAE IDE 安装配置
├── 项目克隆运行
└── 课程安排说明
```

**实训课（2学时）**：
```
任务：搭建开发环境
├── 安装 Rust 工具链
├── 安装 TRAE IDE
├── 克隆 SQLRustGo 项目
├── 运行测试验证环境
└── 提交环境搭建报告
```

---

#### 第2周：结构化设计与UML基础

**理论课（2学时）**：
```
Part 1: 结构化设计方法（25分钟）
├── 结构化设计的历史背景
├── 自顶向下、逐步求精
├── 模块化设计原则
│   ├── 高内聚、低耦合
│   ├── 信息隐藏
│   └── 模块独立性
└── 数据流图（DFD）与数据字典

Part 2: UML概述（25分钟）
├── UML的历史和发展
├── UML 2.0 分类
│   ├── 结构图：类图、对象图、组件图、部署图
│   └── 行为图：用例图、顺序图、活动图、状态图
├── UML工具介绍
│   ├── PlantUML（文本到图形）
│   ├── Draw.io
│   └── StarUML
└── AI辅助UML绘图

Part 3: 用例图（25分钟）
├── 用例图的组成元素
│   ├── 参与者（Actor）
│   ├── 用例（Use Case）
│   ├── 关系（关联、包含、扩展、泛化）
├── 用例图绘制规范
├── 实例：SQLRustGo用例图
│   ├── 用户连接数据库
│   ├── 执行SQL查询
│   ├── 管理表结构
│   └── 事务处理
└── 使用AI生成用例图

Part 4: 实践练习（15分钟）
├── 绘制SQLRustGo用例图
├── 使用PlantUML语法
└── AI辅助优化
```

**实训课（2学时）**：
```
任务：使用AI辅助绘制UML用例图
├── 分析SQLRustGo功能需求
├── 识别参与者和用例
├── 使用PlantUML绘制用例图
├── 使用AI优化设计
└── 提交用例图文档
```

---

#### 第3周：面向对象设计与类图

**理论课（2学时）**：
```
Part 1: 面向对象设计原则（25分钟）
├── 面向对象核心概念
│   ├── 封装
│   ├── 继承
│   └── 多态
├── SOLID原则
│   ├── 单一职责原则（SRP）
│   ├── 开闭原则（OCP）
│   ├── 里氏替换原则（LSP）
│   ├── 接口隔离原则（ISP）
│   └── 依赖倒置原则（DIP）
└── 设计模式简介

Part 2: 类图（25分钟）
├── 类图的组成元素
│   ├── 类名、属性、方法
│   ├── 访问修饰符
│   └── 关系类型
├── 类之间的关系
│   ├── 关联（Association）
│   ├── 聚合（Aggregation）
│   ├── 组合（Composition）
│   ├── 依赖（Dependency）
│   ├── 泛化（Generalization）
│   └── 实现（Realization）
└── 类图绘制规范

Part 3: SQLRustGo类图设计（25分钟）
├── 核心类设计
│   ├── Value（数据值类型）
│   ├── Token（词法单元）
│   ├── Statement（SQL语句AST）
│   ├── Expression（表达式）
│   ├── Page（存储页）
│   ├── BufferPool（缓冲池）
│   └── ExecutionEngine（执行引擎）
├── 类关系分析
└── 使用AI生成类图

Part 4: 实践练习（15分钟）
├── 绘制核心模块类图
├── 识别类之间的关系
└── AI辅助优化设计
```

**实训课（2学时）**：
```
任务：使用AI辅助设计类图
├── 分析SQLRustGo核心模块
├── 设计核心类结构
├── 使用PlantUML绘制类图
├── 使用AI优化设计
└── 提交类图文档
```

---

#### 第4周：顺序图、状态图与架构设计

**理论课（2学时）**：
```
Part 1: 顺序图（20分钟）
├── 顺序图的组成元素
│   ├── 对象（Object）
│   ├── 生命线（Lifeline）
│   ├── 消息（Message）
│   └── 激活（Activation）
├── 顺序图绘制规范
├── 实例：SQL查询执行顺序图
│   ├── 客户端 → Parser → Executor → Storage
│   └── 消息传递和返回
└── 使用AI生成顺序图

Part 2: 状态图（20分钟）
├── 状态图的组成元素
│   ├── 状态（State）
│   ├── 转换（Transition）
│   ├── 事件（Event）
│   └── 动作（Action）
├── 状态图绘制规范
├── 实例：事务状态图
│   ├── Idle → Active → Committed/Rolledback
│   └── 状态转换条件
└── 使用AI生成状态图

Part 3: 架构图与部署图（25分钟）
├── 架构图类型
│   ├── 分层架构图
│   ├── 模块架构图
│   └── 组件架构图
├── SQLRustGo四层架构
│   ├── Parser（解析层）
│   ├── Planner（计划层）
│   ├── Executor（执行层）
│   └── Storage（存储层）
├── 部署图
│   ├── 节点（Node）
│   ├── 组件部署
│   └── 网络拓扑
└── 使用AI生成架构图

Part 4: 快速原型法（25分钟）
├── 快速原型法的概念
├── 原型法开发流程
│   ├── 需求分析
│   ├── 快速设计
│   ├── 原型构建
│   ├── 用户评估
│   └── 迭代改进
├── SQLRustGo草稿版本分析
│   ├── 项目实施计划
│   ├── 核心类型系统
│   ├── 词法/语法分析器原型
│   └── 存储引擎基础
└── AI辅助快速原型开发
```

**实训课（2学时）**：
```
任务：使用AI辅助绘制UML图
├── 绘制SQL查询执行顺序图
├── 绘制事务状态图
├── 绘制系统架构图
├── 使用AI优化设计
└── 提交UML设计文档
```

---

#### 第5周：架构设计原理与SQLRustGo架构

**理论课（2学时）**：
```
Part 1: 架构设计概述（25分钟）- What/Why/How
├── What：什么是软件架构
│   ├── 定义：软件系统的高层结构
│   ├── 架构的层次：业务架构、应用架构、数据架构、技术架构
│   ├── 架构的核心要素：组件、连接器、约束
│   └── 架构设计原则：高内聚低耦合、关注点分离、单一职责
├── Why：为什么需要架构设计
│   ├── 复杂性管理：大型系统包含数百万行代码
│   ├── 质量保证：架构决定系统的质量属性
│   ├── 团队协作：清晰的架构让多人协作成为可能
│   ├── 风险控制：架构设计提前识别风险
│   ├── 成本控制：架构设计成本 << 重构成本
│   └── 业界案例：Google、Netflix、微信
└── How：如何进行架构设计
    ├── 架构设计流程：需求分析→风格选择→组件设计→架构评估→迭代优化
    ├── 架构风格选择：分层架构、微服务架构、事件驱动架构
    ├── 架构评估方法：ATAM、SAAM
    └── AI辅助架构设计：提示词设计、方案评估

Part 2: SQLRustGo四层架构设计（30分钟）- What/Why/How
├── What：SQLRustGo的架构设计
│   ├── 整体架构图
│   ├── Parser Layer（解析层）：Lexer → Parser → AST
│   ├── Planner Layer（规划层）：Logical Plan → Physical Plan
│   ├── Executor Layer（执行层）：Volcano Model → Operators
│   └── Storage Layer（存储层）：Page → BufferPool → B+Tree → WAL
├── Why：为什么选择四层架构
│   ├── 分层架构的优势：关注点分离、易于理解、易于测试、易于扩展
│   ├── 数据库系统的特性：解析层、规划层、执行层、存储层
│   ├── 教学价值：每层对应数据库系统的核心概念
│   └── 可扩展性：可以独立替换某一层的实现
└── How：四层架构的详细设计
    ├── Parser Layer：Lexer、Parser、AST
    ├── Planner Layer：LogicalPlanner、PhysicalPlanner、Optimizer
    ├── Executor Layer：ExecutionEngine、Operators、Volcano Model
    └── Storage Layer：Page、BufferPool、BPlusTree、WAL、TransactionManager

Part 3: 架构图绘制实践（20分钟）
├── 使用PlantUML绘制架构图
│   ├── PlantUML组件图语法
│   ├── SQLRustGo架构图代码
│   └── 使用AI生成架构图代码
└── 架构设计评审
    ├── 评审要点：架构是否清晰？职责是否分离？是否易于扩展？
    └── 评审方法：同行评审、架构评估会议、架构权衡分析

Part 4: AI辅助架构设计实践（10分钟）
├── 使用AI生成架构方案
│   ├── 提示词设计
│   ├── 方案评估
│   └── 迭代优化
└── 使用AI生成架构图
    ├── PlantUML代码生成
    ├── 图形渲染
    └── 文档输出
```

**实训课（2学时）**：
```
任务：完成SQLRustGo架构设计
├── 绘制SQLRustGo架构图（使用PlantUML）
├── 编写架构设计文档
├── 使用AI生成架构方案并评估
└── Git提交架构设计文档
```

---

#### 第6周：功能模块划分与接口设计

**理论课（2学时）**：
```
Part 1: 功能模块划分（25分钟）- What/Why/How
├── What：什么是功能模块
│   ├── 定义：功能模块是具有独立功能的软件单元
│   ├── 模块的特性：独立性、可重用性、可替换性、封装性
│   ├── 模块的粒度：粗粒度模块 vs 细粒度模块
│   └── 模块划分原则：高内聚、低耦合、单一职责、接口稳定
├── Why：为什么需要功能模块划分
│   ├── 复杂性管理：模块化将复杂问题分解为简单问题
│   ├── 团队协作：不同团队可以负责不同模块
│   ├── 可维护性：模块化使代码更易理解和修改
│   ├── 可测试性：模块可以独立测试
│   ├── 可扩展性：新功能可以作为新模块添加
│   └── 业界案例：Linux内核、Chrome浏览器、VS Code
└── How：如何进行功能模块划分
    ├── 模块划分方法：按功能划分、按层次划分、按数据划分
    ├── 模块划分流程：需求分析→功能聚类→模块识别→接口设计→依赖分析→迭代优化
    ├── 模块划分评估：内聚度评估、耦合度评估、复杂度评估、可测试性评估
    └── AI辅助模块划分：使用AI分析需求文档，识别功能模块

Part 2: SQLRustGo功能模块划分（30分钟）- What/Why/How
├── What：SQLRustGo的模块划分方案
│   ├── Parser模块：Lexer、Parser、AST
│   ├── Planner模块：LogicalPlanner、PhysicalPlanner、Optimizer
│   ├── Executor模块：ExecutionEngine、Operators
│   ├── Storage模块：PageManager、BufferPool、BPlusTree、WAL、TransactionManager
│   └── Common模块：Value、DataType、SqlError
├── Why：为什么这样划分模块
│   ├── 模块依赖关系：Parser → Common, Planner → Parser, Executor → Planner, Storage
│   ├── 依赖方向：上层依赖下层，下层不依赖上层
│   └── 避免循环依赖
└── How：模块接口设计
    ├── Parser模块接口：Lexer trait, Parser trait
    ├── Planner模块接口：LogicalPlanner trait, PhysicalPlanner trait
    ├── Executor模块接口：ExecutionEngine trait
    └── Storage模块接口：PageManager trait, BufferPool trait

Part 3: 接口设计原则与实践（20分钟）- What/Why/How
├── What：什么是接口设计
│   ├── 接口的定义：模块之间交互的契约
│   ├── 接口的组成：方法签名、行为契约、错误处理
│   └── 接口的类型：同步接口、异步接口、流式接口
├── Why：接口设计的重要性
│   ├── 解耦：接口降低模块之间的耦合度
│   ├── 可测试性：接口使Mock和Stub更容易实现
│   ├── 可替换性：接口允许替换实现而不影响调用者
│   ├── 可扩展性：接口支持新功能的添加
│   └── 文档作用：接口本身就是文档
└── How：接口设计原则
    ├── 接口隔离原则（ISP）：接口要小而专一
    ├── 最小知识原则（Law of Demeter）：模块只与直接的朋友通信
    ├── 契约式设计（Design by Contract）：明确前置条件、后置条件、不变式
    ├── 错误处理原则：使用Result类型表示可能失败的操作
    └── Rust接口设计实践：使用trait定义接口、使用泛型支持多种实现

Part 4: AI辅助接口设计实践（10分钟）
├── 使用AI设计接口
│   ├── 提示词设计：设计数据库缓冲池的接口
│   ├── 评估接口设计：接口是否简洁？完整？稳定？
│   └── 迭代优化
└── 接口评审
    ├── 评审要点：接口是否简洁？完整？稳定？错误处理是否合理？
    └── 评审方法：同行评审、接口评审会议、AI辅助评审
```

**实训课（2学时）**：
```
任务：完成SQLRustGo模块划分和接口设计
├── 完成SQLRustGo模块划分文档
├── 设计所有模块的接口
├── 绘制模块依赖图
├── 使用AI辅助接口设计
└── Git提交模块设计文档
```

---

#### 第7周：AI辅助核心模块实现

**理论课（2学时）**：
```
Part 1: AI辅助开发概述（20分钟）- What/Why/How
├── What：AI辅助开发是什么
│   ├── 定义：使用AI工具辅助软件开发的各个环节
│   ├── AI辅助开发的阶段：需求分析、设计、编码、测试、文档
│   └── AI辅助开发工具：AI-IDE、AI编程助手、AI聊天机器人、AI代码审查
├── Why：为什么使用AI辅助开发
│   ├── 提高效率：开发效率提升2-5倍
│   ├── 降低门槛：新手可以借助AI快速上手
│   ├── 提高质量：AI可以生成规范的代码
│   ├── 加速学习：AI可以解释概念、提供示例
│   └── 业界案例：GitHub Copilot提高55%编码速度
└── How：如何有效使用AI辅助开发
    ├── AI辅助开发流程：明确需求→设计提示词→生成代码→代码审查→测试验证→迭代优化
    ├── 提示词工程：清晰性、完整性、结构性、可迭代性
    ├── 代码审查要点：正确性、安全性、性能、可读性、可维护性
    └── AI辅助开发的局限性：上下文窗口限制、创造性限制、领域知识限制

Part 2: AI辅助实现词法分析器（30分钟）- What/Why/How
├── What：词法分析原理
│   ├── 词法分析的作用：将SQL字符串转换为Token流
│   ├── Token类型：关键字、标识符、字面量、运算符、分隔符
│   ├── 正则表达式：描述Token的模式
│   └── 有限状态机（FSM）：实现词法分析器
├── Why：为什么使用AI辅助实现
│   ├── 快速生成样板代码
│   ├── 减少重复工作
│   ├── 学习最佳实践
│   └── 提高开发效率
└── How：使用AI实现词法分析器
    ├── 提示词设计：生成Token定义
    ├── 提示词设计：生成词法分析器
    ├── 代码审查：检查逻辑正确性、错误处理、边界条件
    └── 测试验证：编写测试用例、验证功能

Part 3: AI辅助实现语法分析器（30分钟）- What/Why/How
├── What：语法分析原理
│   ├── 语法分析的作用：将Token流转换为AST
│   ├── 上下文无关文法：描述SQL语法
│   ├── 抽象语法树（AST）：表示SQL语句的结构
│   └── 递归下降解析：实现语法分析器
├── Why：为什么使用AI辅助实现
│   ├── 语法规则复杂，AI可以快速生成
│   ├── AST结构设计需要经验，AI可以提供建议
│   └── 错误处理繁琐，AI可以生成完善的错误处理
└── How：使用AI实现语法分析器
    ├── 提示词设计：生成AST定义
    ├── 提示词设计：生成语法分析器
    ├── 代码审查：检查解析逻辑、错误处理、SQL语句支持
    └── 测试验证：编写测试用例、验证功能

Part 4: AI辅助实现存储引擎（30分钟）- What/Why/How
├── What：存储引擎原理
│   ├── 页式存储：数据以页为单位存储
│   ├── 缓冲池：管理内存中的页
│   ├── B+树索引：加速数据查询
│   └── WAL日志：保证事务持久性
├── Why：为什么使用AI辅助实现
│   ├── 存储引擎涉及复杂数据结构
│   ├── 并发控制需要考虑线程安全
│   └── AI可以生成规范的数据结构实现
└── How：使用AI实现存储引擎
    ├── 提示词设计：设计页结构
    ├── 提示词设计：实现缓冲池
    ├── 代码审查：检查LRU算法、并发安全、脏页管理
    └── 测试验证：编写测试用例、验证功能
```

**实训课（2学时）**：
```
任务：使用AI实现核心模块
├── 完成词法分析器实现
├── 完成语法分析器实现
├── 完成页结构和缓冲池实现
├── 编写测试用例
└── Git提交代码
```

---

#### 第8周：测试驱动开发与Alpha版本

**理论课（2学时）**：
```
Part 1: 测试驱动开发（TDD）（25分钟）- What/Why/How
├── What：TDD的核心思想
│   ├── 测试先行：先写测试，再写代码
│   ├── 快速反馈：测试立即反馈代码是否正确
│   ├── 持续重构：在测试保护下重构代码
│   └── Red-Green-Refactor循环
├── Why：测试先行的好处
│   ├── 更好的设计：从使用者角度设计接口
│   ├── 更高的测试覆盖率：每个功能都有对应的测试
│   ├── 更少的Bug：测试捕获大部分Bug
│   └── 文档作用：测试就是活文档
└── How：TDD实践技巧
    ├── 从简单测试开始：先写最简单的测试
    ├── 保持测试独立：测试之间不应该有依赖
    ├── 测试命名规范：test_lexer_should_recognize_select_keyword
    └── 使用AI辅助TDD：AI可以生成测试用例、生成实现代码、建议重构方案

Part 2: AI辅助测试生成（25分钟）- What/Why/How
├── What：使用AI生成测试用例
│   ├── 提示词设计：为词法分析器生成测试用例
│   ├── AI输出示例：测试关键字、标识符、数字字面量
│   └── 人工审查：检查AI生成的测试是否完整
├── Why：使用AI辅助测试
│   ├── 快速生成测试用例
│   ├── 发现边界条件
│   ├── 提高测试覆盖率
│   └── 减少重复工作
└── How：AI辅助测试流程
    ├── 使用AI生成测试用例
    ├── 使用AI分析测试覆盖率
    ├── 使用AI发现边界条件
    └── 实例：SQLRustGo测试

Part 3: Rust测试框架（20分钟）
├── #[test] 属性
├── assert! 宏系列：assert!, assert_eq!, assert_ne!
├── 测试组织：单元测试（#[cfg(test)]）、集成测试（tests/目录）、文档测试
└── 测试覆盖率工具：cargo-tarpaulin, cargo-llvm-cov

Part 4: Alpha版本验收（20分钟）
├── Alpha版本定义
│   ├── 功能完整性：核心功能已实现
│   ├── 可运行：系统可以启动和运行
│   ├── 有测试：单元测试覆盖核心功能，覆盖率≥70%
│   └── 有文档：README文档、API文档、设计文档
├── 功能验收标准
│   ├── SQL解析：支持SELECT、INSERT、UPDATE、DELETE、CREATE TABLE
│   ├── 存储引擎：支持数据读写、页管理、缓冲池
│   └── 执行引擎：支持基本查询执行
├── 质量门禁
│   ├── 编译通过：cargo build
│   ├── 测试通过：cargo test
│   ├── Clippy无警告：cargo clippy
│   ├── 格式化通过：cargo fmt --check
│   └── 覆盖率≥70%：cargo tarpaulin
└── Alpha版本发布
    ├── 创建版本标签：git tag v0.1.0-alpha
    ├── 编写Release Notes
    └── 发布公告
```

**实训课（2学时）**：
```
任务：完成Alpha版本
├── 补充单元测试
├── 提高测试覆盖率至70%+
├── 运行所有质量检查
├── 修复发现的问题
├── Git提交Alpha版本
└── 编写Alpha版本Release Notes
```

---

## 第二阶段：协同开发与工程治理（第9-16周）

### 阶段目标

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    第二阶段目标：协同开发与质量保证                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   知识目标                                                                   │
│   ────────                                                                   │
│   • 理解软件治理的概念和方法                                                 │
│   • 理解Git分支策略和版本管理                                                │
│   • 理解PR工作流和代码审核机制                                               │
│   • 理解CI/CD自动化原理                                                      │
│   • 理解项目成熟度评估方法                                                   │
│   • 理解多AI协同工作流                                                       │
│                                                                              │
│   能力目标                                                                   │
│   ────────                                                                   │
│   • 能够使用软件治理约束开发过程                                             │
│   • 能够配置Git分支保护规则                                                  │
│   • 能够执行PR流程和代码审核                                                 │
│   • 能够配置CI/CD自动化流程                                                  │
│   • 能够评估项目成熟度                                                       │
│   • 能够使用多AI协同工作                                                     │
│                                                                              │
│   产出目标                                                                   │
│   ────────                                                                   │
│   • 完成Beta版本（用户文档、安装程序、测试计划）                              │
│   • 完成RC1版本（门禁检查、安全扫描）                                         │
│   • 完成Release/1.0正式发布                                                  │
│   • 完成v2.0规划                                                             │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 详细教学计划

#### 第9周：软件治理与分支策略

**理论课（2学时）**：
```
Part 1: 软件治理概述（25分钟）- What/Why/How
├── What：什么是软件治理
│   ├── 定义：用规则和流程约束软件开发过程
│   ├── 治理层次：代码治理、流程治理、质量治理、安全治理
│   ├── 治理范围：开发阶段、测试阶段、发布阶段、运维阶段
│   └── 治理工具链：代码规范、代码审核、质量门禁、安全扫描
├── Why：为什么需要软件治理
│   ├── 规模化挑战：代码规模增长、团队规模增长、复杂度指数级增长
│   ├── 质量保证：防止代码腐烂、保证代码一致性、降低维护成本
│   ├── 风险控制：防止破坏性变更、保证发布质量、快速回滚能力
│   ├── 效率提升：减少重复工作、提高协作效率、加速开发迭代
│   └── 业界案例：Google代码审查制度、Microsoft分支保护策略、Amazon质量门禁体系
└── How：如何实施软件治理
    ├── 治理框架：制定规则→建立流程→配置工具→持续改进
    ├── 治理工具链：ESLint、Prettier、Rustfmt、GitHub PR、Gerrit、SonarQube
    ├── 治理实践：从小到大、从松到严、持续优化
    └── SQLRustGo治理实践：代码规范、流程规范、质量门禁、安全治理

Part 2: Git分支策略（20分钟）- What/Why/How
├── What：什么是分支策略
│   ├── 定义：管理代码分支创建、合并、删除的规则和流程
│   ├── 分支策略的作用：并行开发、隔离风险、版本管理、发布控制
│   └── 常见分支策略：Git Flow、GitHub Flow、Trunk Based Development
├── Why：为什么需要分支策略
│   ├── 协作需求：多人同时开发需要隔离、避免代码冲突、提高开发效率
│   ├── 质量控制：主分支保持稳定、功能开发不影响主分支、发布版本可追溯
│   └── 风险管理：功能失败不影响其他功能、快速回滚到稳定版本
└── How：SQLRustGo分支策略
    ├── 分支类型：main、develop、feature/*、release/*、hotfix/*
    ├── 分支命名规范：feature/add-join-support、release/v1.0.0、hotfix/fix-buffer-pool-leak
    └── 分支生命周期管理

Part 3: 分支保护与代码审核（20分钟）
├── 分支保护规则
│   ├── 主分支保护：禁止直接推送、必须通过PR合并、需要代码审查批准、需要通过CI检查
│   └── GitHub分支保护配置：Settings → Branches → Add rule
├── 代码审核流程
│   ├── Pull Request流程：创建功能分支→编写代码和测试→提交Pull Request→代码审核→修改代码→审核通过→合并到主分支
│   └── 代码审核要点：功能正确性、代码质量、测试覆盖、文档完整
└── 代码审核实践
    ├── 审核者职责：检查代码质量、提出改进建议、确保符合规范、批准或拒绝PR
    ├── 提交者职责：编写清晰的PR描述、提供必要的上下文、及时响应审核意见
    └── 审核工具：GitHub PR Review、Gerrit、Phabricator

Part 4: 实践练习（15分钟）
├── 创建功能分支
├── 提交Pull Request
├── 参与代码审核
└── 合并代码
```

**实训课（2学时）**：
```
任务：配置分支保护规则和PR流程
├── 创建开发分支
├── 配置分支保护规则
├── 测试保护规则
├── 创建功能分支
├── 实现一个小功能
├── 创建PR
├── 进行代码审核
└── Git提交配置
```

---

#### 第10周：PR工作流与项目成熟度评估

**理论课（2学时）**：
```
Part 1: PR工作流详解（25分钟）- What/Why/How
├── What：什么是PR工作流
│   ├── PR定义：一种代码合并请求机制，用于代码审核和讨论
│   ├── PR工作流的作用：代码审核、知识共享、历史记录、自动化检查
│   └── PR生命周期：创建功能分支→提交代码→创建PR→代码审核→修改→合并
├── Why：为什么使用PR工作流
│   ├── 质量保证：多人审核代码、发现潜在问题、保证代码规范
│   ├── 知识传递：团队成员了解代码变更、分享最佳实践、新成员快速上手
│   └── 协作效率：集中讨论代码变更、减少会议时间、异步协作
└── How：PR工作流最佳实践
    ├── 创建PR：PR标题规范、PR描述模板、关联Issue
    ├── 审核PR：审核检查清单、审核意见类型、审核礼仪
    └── 合并PR：合并前检查、合并方式选择、合并后清理

Part 2: 项目成熟度评估（25分钟）- What/Why/How
├── What：什么是项目成熟度
│   ├── 定义：项目在功能完整性、代码质量、文档完善度等方面的综合评估
│   ├── 成熟度等级：原型→Alpha→Beta→RC→Release
│   └── 评估维度：代码质量、功能完整性、文档完善、CI/CD、安全合规
├── Why：为什么需要成熟度评估
│   ├── 项目管理：了解项目当前状态、规划下一步工作、分配资源
│   ├── 质量控制：确保达到发布标准、识别质量风险、持续改进
│   └── 沟通协作：向利益相关者报告进度、团队对齐目标、用户了解产品状态
└── How：v2.0成熟度评估
    ├── 评估维度：代码质量（测试覆盖率≥80%）、功能完整性（核心功能100%）、文档完善（API文档100%）、CI/CD（自动化检查100%）、安全合规（依赖扫描、代码扫描）
    ├── 评估结果：综合评分85%，达到Beta级别
    └── 改进计划：提高测试覆盖率、完善API文档、添加安全扫描

Part 3: v2.0功能规划（20分钟）
├── JOIN支持：INNER JOIN、LEFT JOIN、RIGHT JOIN、FULL OUTER JOIN
├── 子查询支持：WHERE子句子查询、FROM子句子查询、SELECT子句子查询
├── 视图支持：CREATE VIEW、DROP VIEW、视图查询
└── 开发周期：JOIN支持（第10-12周）、子查询支持（第13-14周）、视图支持（第15周）

Part 4: 实践练习（20分钟）
├── 创建v2.0功能分支
├── 编写功能设计文档
└── 提交PR进行审核
```

**实训课（2学时）**：
```
任务：完成PR流程和v2.0规划
├── 创建功能分支
├── 实现一个小功能
├── 创建PR
├── 进行代码审核
├── 合并代码
└── 编写v2.0功能设计文档
```

---

#### 第11周：CI/CD与OpenClaw自动化

**理论课（2学时）**：
```
Part 1: CI/CD概述（25分钟）- What/Why/How
├── What：什么是CI/CD
│   ├── CI（持续集成）：频繁集成代码到主分支，自动化构建和测试
│   ├── CD（持续交付/部署）：自动化部署流程，快速交付价值
│   └── CI/CD流程：代码提交→自动构建→自动测试→代码审查→自动部署
├── Why：为什么需要CI/CD
│   ├── 提高质量：自动化测试保证质量，快速发现问题，减少人为错误
│   ├── 提高效率：自动化重复工作，加快交付速度，减少手动操作
│   └── 降低风险：小批量频繁发布，快速回滚能力，减少发布风险
└── How：CI/CD流程设计
    ├── CI流程：代码提交→自动构建→自动测试→代码审查
    ├── CD流程：自动打包→自动部署→自动监控
    └── CI/CD工具：GitHub Actions、GitLab CI、Jenkins

Part 2: GitHub Actions实践（25分钟）- What/Why/How
├── What：GitHub Actions配置
│   ├── Workflow配置：.github/workflows/ci.yml
│   ├── Job和Step：jobs、steps、uses、run
│   ├── 触发条件：on: push、pull_request、schedule
│   └── 环境变量：env、secrets
├── Why：为什么使用GitHub Actions
│   ├── 与GitHub深度集成：无需额外配置，自动触发
│   ├── 丰富的Action市场：大量可复用的Action
│   ├── 免费额度：公开仓库免费，私有仓库有免费额度
│   └── 易于配置：YAML格式，版本控制
└── How：SQLRustGo CI配置
    ├── 测试自动化：cargo test、覆盖率报告
    ├── 代码检查：cargo fmt --check、cargo clippy
    ├── 质量门禁：测试覆盖率≥80%、Clippy无警告
    └── 自动化发布：创建Release、发布产物

Part 3: OpenClaw多AI协作（25分钟）- What/Why/How
├── What：什么是OpenClaw
│   ├── 定义：多AI协作的自动化工作流平台
│   ├── 核心功能：AI角色分配、自动化工作流、协作机制
│   └── AI角色：分析师、架构师、开发者、测试员、文档员、审查员
├── Why：为什么需要多AI协作
│   ├── 提高效率：并行处理任务、专业分工、24/7工作
│   ├── 提高质量：多AI审核、交叉验证、减少遗漏
│   └── 降低成本：减少人工干预、自动化重复工作
└── How：AI角色分配与协作流程
    ├── AI角色定义：分析师（需求分析）、架构师（架构设计）、开发者（代码编写）、测试员（测试用例）、文档员（文档编写）、审查员（代码审查）
    ├── 协作流程：分析师→架构师→开发者→测试员→审查员→文档员
    └── 任务分配：JOIN功能开发、子查询功能开发、视图功能开发

Part 4: 实践练习（15分钟）
├── 配置GitHub Actions CI流程
├── 设计AI协作流程
└── 执行一次完整的CI/CD流程
```

**实训课（2学时）**：
```
任务：配置CI/CD和AI协作
├── 创建GitHub Actions配置
├── 配置测试自动化
├── 配置代码检查
├── 配置覆盖率报告
├── 设计AI协作流程
└── 验证CI运行
```

---

#### 第12周：性能优化与重构

**理论课（2学时）**：
```
Part 1: 性能优化概述（25分钟）- What/Why/How
├── What：什么是性能优化
│   ├── 定义：通过优化代码、算法、架构等手段，提高系统的性能指标
│   ├── 性能指标：响应时间、吞吐量、资源利用率、并发能力
│   └── 性能优化层次：算法优化、代码优化、架构优化、系统优化
├── Why：为什么需要性能优化
│   ├── 用户体验：快速响应提高用户满意度、降低等待时间、提高系统可用性
│   ├── 成本控制：提高资源利用率、降低硬件成本、降低运营成本
│   └── 竞争优势：性能是产品竞争力、快速响应吸引用户、高并发支撑业务增长
└── How：性能优化方法
    ├── 算法优化：选择更优的算法、优化时间复杂度、优化空间复杂度
    ├── 代码优化：减少不必要的计算、优化数据结构、使用更高效的库
    ├── 架构优化：缓存策略、负载均衡、分布式架构
    └── 系统优化：操作系统调优、数据库优化、网络优化

Part 2: 性能分析方法（25分钟）- What/Why/How
├── What：性能分析工具
│   ├── Rust性能工具：cargo bench、cargo flamegraph、perf、valgrind
│   ├── 基准测试：#[bench]属性、基准测试设计
│   └── 性能分析：火焰图、热点分析、内存分析
├── Why：为什么需要性能分析
│   ├── 识别瓶颈：定位性能热点、发现性能问题
│   ├── 量化改进：对比优化前后性能、验证优化效果
│   └── 持续监控：监控性能变化、及时发现性能退化
└── How：性能分析流程
    ├── 建立基准：测量当前性能、设定性能目标
    ├── 识别瓶颈：使用性能分析工具、定位热点代码
    ├── 优化代码：针对瓶颈进行优化、保持代码正确性
    └── 验证效果：对比优化前后性能、确认达到目标

Part 3: 代码重构（25分钟）- What/Why/How
├── What：什么是代码重构
│   ├── 定义：在不改变代码外部行为的前提下，改善代码内部结构
│   ├── 重构的目的：提高代码可读性、可维护性、可扩展性、减少技术债务
│   └── 重构模式：提取方法、提取类、内联方法、移动方法
├── Why：为什么需要重构
│   ├── 代码质量：消除代码异味、提高代码质量、降低维护成本
│   ├── 技术债务：偿还技术债务、防止债务累积、提高开发效率
│   └── 团队协作：提高代码可读性、降低理解成本、提高协作效率
└── How：重构方法
    ├── 小步重构：每次只重构一小部分、保持测试通过、频繁提交
    ├── 重构模式：提取方法、提取类、内联方法、移动方法
    └── AI辅助重构：使用AI识别重构点、使用AI执行重构、使用AI验证重构

Part 4: SQLRustGo性能优化实践（15分钟）
├── 查询优化：使用索引加速查询、优化执行计划、减少数据扫描
├── 缓存优化：查询结果缓存、执行计划缓存、元数据缓存
└── 并发优化：多线程查询执行、连接池管理、锁优化
```

**实训课（2学时）**：
```
任务：性能优化与重构
├── 编写基准测试
├── 进行性能分析
├── 识别性能瓶颈
├── 执行优化和重构
└── 验证优化效果
```

---

#### 第13周：安全扫描与审计

**理论课（2学时）**：
```
Part 1: 软件安全概述（25分钟）- What/Why/How
├── What：什么是软件安全
│   ├── 定义：保护软件系统免受恶意攻击和未授权访问
│   ├── 安全目标：机密性、完整性、可用性
│   ├── 常见安全威胁：SQL注入、缓冲区溢出、XSS、CSRF
│   └── 安全扫描方法：静态分析（SAST）、动态分析（DAST）、依赖扫描（SCA）
├── Why：为什么需要安全扫描
│   ├── 数据保护：保护用户数据、防止数据泄露、符合隐私法规
│   ├── 业务连续性：防止攻击导致服务中断、保证业务正常运行、降低安全风险
│   └── 合规要求：满足安全合规要求、通过安全审计、避免法律风险
└── How：安全扫描方法
    ├── 静态分析（SAST）：分析源代码、发现潜在漏洞、早期发现安全问题
    ├── 动态分析（DAST）：运行时分析、模拟攻击、发现运行时漏洞
    └── 依赖扫描（SCA）：扫描第三方依赖、发现已知漏洞、及时更新依赖

Part 2: 依赖扫描（25分钟）- What/Why/How
├── What：什么是依赖扫描
│   ├── 定义：扫描项目依赖的第三方库，发现已知安全漏洞
│   ├── 扫描内容：直接依赖、间接依赖、许可证合规
│   └── 扫描工具：cargo-audit、Dependabot、Snyk
├── Why：为什么需要依赖扫描
│   ├── 供应链攻击：第三方库可能包含漏洞、依赖越多风险越大、供应链攻击日益增多
│   └── 已知漏洞：CVE数据库记录已知漏洞、及时发现和修复漏洞、降低安全风险
└── How：依赖扫描实践
    ├── cargo-audit：安装、扫描、修复
    ├── Dependabot：配置、自动更新、自动PR
    └── SQLRustGo依赖扫描：Cargo.toml依赖、扫描结果、修复建议

Part 3: 代码扫描（25分钟）- What/Why/How
├── What：什么是代码扫描
│   ├── 定义：分析源代码，发现潜在的安全漏洞
│   ├── 扫描内容：SQL注入、缓冲区溢出、敏感信息泄露、不安全的加密
│   └── 扫描工具：Clippy、SonarQube、CodeQL
├── Why：为什么需要代码扫描
│   ├── 早期发现：在开发阶段发现问题、降低修复成本、提高代码质量
│   └── 自动化：自动扫描代码、减少人工审查、提高效率
└── How：代码扫描实践
    ├── Clippy安全检查：cargo clippy -- -W clippy::all
    ├── SonarQube：代码质量和安全扫描、支持多种语言、集成CI/CD
    ├── CodeQL：GitHub代码扫描、查询语言、自定义规则
    └── SQLRustGo代码扫描：SQL注入检查、敏感信息检查、加密检查

Part 4: 实践练习（15分钟）
├── 执行依赖扫描
├── 执行代码扫描
└── 修复发现的安全问题
```

**实训课（2学时）**：
```
任务：执行安全扫描
├── 安装cargo-audit
├── 扫描项目依赖
├── 修复发现的漏洞
├── 运行Clippy安全检查
├── 修复发现的问题
└── Git提交修复代码
```

---

#### 第14周：发布门禁与检查清单

**理论课（2学时）**：
```
Part 1: 发布门禁概述（25分钟）- What/Why/How
├── What：什么是发布门禁
│   ├── 定义：发布前必须通过的检查点，确保发布质量
│   ├── 门禁的作用：质量保证、风险控制、流程规范
│   └── 门禁类型：代码门禁、质量门禁、安全门禁、功能门禁、性能门禁、文档门禁
├── Why：为什么需要发布门禁
│   ├── 质量保证：防止低质量代码发布、确保功能正确性、保证性能达标
│   ├── 风险控制：防止安全漏洞发布、防止严重Bug发布、降低发布风险
│   └── 团队协作：明确发布标准、减少争议、提高协作效率
└── How：门禁配置
    ├── 代码门禁：编译检查、测试检查、格式化检查、Clippy检查
    ├── 质量门禁：测试覆盖率、代码质量
    ├── 安全门禁：依赖扫描、代码扫描
    ├── 功能门禁：集成测试、回归测试
    ├── 性能门禁：性能测试、压力测试
    └── 文档门禁：文档完整性、API文档

Part 2: 门禁类型与配置（25分钟）- What/Why/How
├── What：门禁类型详解
│   ├── 代码门禁：编译、测试、格式化、Clippy
│   ├── 质量门禁：测试覆盖率≥80%、代码质量A级
│   ├── 安全门禁：依赖扫描无漏洞、代码扫描无高危
│   ├── 功能门禁：集成测试通过、回归测试通过
│   ├── 性能门禁：查询响应时间<100ms、并发能力>1000 QPS
│   └── 文档门禁：README完善、API文档100%、用户手册完善
├── Why：为什么需要多类型门禁
│   ├── 全面覆盖：从多个维度保证质量
│   ├── 早期发现：在不同阶段发现问题
│   └── 自动化：减少人工检查、提高效率
└── How：门禁配置实践
    ├── GitHub Actions配置：workflow文件、job和step、触发条件
    ├── 门禁脚本编写：检查脚本、报告生成、失败处理
    └── SQLRustGo门禁配置：CI配置、质量门禁、安全门禁

Part 3: RC版本验收（25分钟）- What/Why/How
├── What：RC版本定义
│   ├── Release Candidate：发布候选版本
│   ├── RC版本特征：功能完整、质量达标、文档完善、测试充分
│   └── RC版本验收：通过所有门禁、准备正式发布
├── Why：为什么需要RC版本验收
│   ├── 质量保证：确保发布版本质量
│   ├── 风险控制：降低发布风险
│   └── 用户信心：提高用户对产品的信心
└── How：RC门禁验收清单
    ├── 代码门禁：编译通过、测试通过、Clippy无警告、格式化通过
    ├── 质量门禁：测试覆盖率≥80%、代码质量A级
    ├── 安全门禁：依赖扫描无漏洞、代码扫描无高危
    ├── 功能门禁：集成测试通过、回归测试通过
    ├── 性能门禁：查询响应时间<100ms、并发能力>1000 QPS
    └── 文档门禁：README完善、API文档100%、用户手册完善

Part 4: 实践练习（15分钟）
├── 配置门禁检查
├── 执行RC版本验收
└── 创建RC版本标签
```

**实训课（2学时）**：
```
任务：建立发布门禁
├── 配置GitHub Actions门禁
├── 添加所有门禁检查
├── 触发CI验证
├── 执行RC版本验收
├── 填写验收清单
└── 创建RC版本标签
```

---

#### 第15周：版本发布与长期规划

**理论课（2学时）**：
```
Part 1: 版本发布流程（25分钟）- What/Why/How
├── What：什么是版本发布
│   ├── 定义：将软件交付给用户使用的过程
│   ├── 发布类型：Major版本、Minor版本、Patch版本
│   └── 发布流程：发布前准备→发布执行→发布后工作
├── Why：为什么需要规范的发布流程
│   ├── 质量保证：确保发布版本质量、减少发布后问题、提高用户信任
│   ├── 用户沟通：明确版本变更、提供升级指南、降低升级风险
│   └── 团队协作：标准化发布流程、明确发布责任、提高协作效率
└── How：版本发布实践
    ├── 发布前准备：功能冻结、代码冻结、门禁验收、文档更新
    ├── 发布执行：创建标签、构建发布包、发布到平台、发布公告
    └── 发布后工作：监控告警、问题处理、版本维护、经验总结

Part 2: 版本号管理（20分钟）- What/Why/How
├── What：语义化版本号
│   ├── 格式：MAJOR.MINOR.PATCH
│   ├── 规则：MAJOR（不兼容变更）、MINOR（向后兼容功能）、PATCH（Bug修复）
│   └── 示例：1.0.0 → 1.0.1（Bug修复）→ 1.1.0（新功能）→ 2.0.0（重大变更）
├── Why：为什么需要语义化版本号
│   ├── 版本管理：清晰的版本演进、明确的变更类型、便于版本追踪
│   ├── 依赖管理：明确兼容性、自动化依赖更新、减少依赖冲突
│   └── 用户沟通：明确升级风险、提供升级建议、降低升级成本
└── How：版本号管理实践
    ├── Cargo.toml版本号：version字段
    ├── Git标签：创建标签、推送标签、列出标签
    └── Release Notes：新功能、Bug修复、破坏性变更、升级指南

Part 3: 长期功能规划（30分钟）- What/Why/How
├── What：长期功能规划
│   ├── v3.0功能：JOIN支持、子查询支持、视图支持
│   ├── v4.0功能：JSON支持、全文搜索、存储过程
│   └── v5.0功能：AI查询优化、自动调优、分布式支持
├── Why：为什么需要长期规划
│   ├── 产品方向：明确产品发展方向、指导开发优先级、协调资源分配
│   ├── 技术演进：规划技术架构演进、避免技术债务、提高系统可扩展性
│   └── 用户期望：管理用户期望、提供产品路线图、增强用户信心
└── How：长期规划实践
    ├── v3.0规划：JOIN支持（4周）、子查询支持（3周）、视图支持（2周）
    ├── v4.0规划：JSON支持（4周）、全文搜索（3周）、存储过程（4周）
    └── v5.0规划：AI查询优化（6周）、自动调优（4周）、分布式支持（8周）

Part 4: 架构演化计划（15分钟）
├── 架构演化方向
│   ├── 性能优化：向量化执行、并行查询、查询缓存
│   ├── 可扩展性：插件架构、存储引擎抽象、执行引擎抽象
│   └── 可靠性：高可用架构、数据备份恢复、故障自动恢复
├── 技术债务管理
│   ├── 识别技术债务：代码异味、架构问题、测试不足
│   ├── 偿还技术债务：定期重构、补充测试、更新文档
│   └── 预防技术债务：代码审查、持续集成、技术培训
└── 团队能力建设
    ├── 技术培训：Rust进阶、数据库原理、性能优化
    ├── 知识分享：技术分享会、代码审查、文档编写
    └── 工具建设：开发工具、测试工具、监控工具
```

**实训课（2学时）**：
```
任务：完成版本发布和长期规划
├── 编写v3.0功能规划文档
├── 设计v3.0技术方案
├── 制定开发计划
├── 创建v1.0.0 Release
├── 编写Release Notes
└── 发布公告
```

---

#### 第16周：项目展示与职业发展

**理论课（2学时）**：
```
Part 1: 项目成果展示（30分钟）
├── SQLRustGo项目回顾
│   ├── 项目目标：构建一个功能完整的SQL数据库
│   ├── 项目成果：SQL解析器、查询优化器、执行引擎、存储引擎、事务处理、并发访问
│   └── 项目统计：代码行数15,000+、测试覆盖率85%、文档完整度90%、性能1200 QPS
├── 功能演示
│   ├── SQL查询演示
│   ├── 事务处理演示
│   └── 并发访问演示
├── 性能演示
│   ├── 查询性能测试
│   ├── 并发性能测试
│   └── 压力测试
└── 代码演示
    ├── 核心代码讲解
    ├── 设计模式应用
    └── 最佳实践分享

Part 2: 课程总结（20分钟）
├── 知识点回顾
│   ├── 上半学期（第1-8周）：软件工程发展历史、Greenfield/Brownfield、UML建模、架构设计、功能模块划分、AI辅助开发、TDD
│   └── 下半学期（第9-16周）：软件治理、分支策略、PR工作流、CI/CD、性能优化、安全扫描、发布门禁、长期规划
├── 能力培养
│   ├── 工程思维：理解软件工程的本质和发展历程、掌握结构化设计和面向对象设计方法
│   ├── UML建模能力：掌握用例图、类图、顺序图、状态图、架构图
│   ├── AI应用能力：理解AI Coding的能力边界、掌握提示词工程基础、能够使用AI工具辅助设计和编码
│   └── 开发能力：能够实现词法分析器和语法分析器、能够实现存储引擎核心模块、能够编写规范的测试用例
└── 课程收获
    ├── 技术能力：掌握Rust编程语言、掌握数据库系统原理、掌握软件工程方法、掌握AI辅助开发
    ├── 工程能力：掌握Git协作开发、掌握CI/CD自动化、掌握测试驱动开发、掌握代码审查
    └── 职业素养：团队协作能力、沟通表达能力、问题解决能力、持续学习能力

Part 3: 职业发展路径（25分钟）
├── 软件工程师职业路径
│   ├── 初级工程师（0-2年）：完成分配的开发任务、编写单元测试、参与代码审查、薪资10-20K/月
│   ├── 中级工程师（2-5年）：独立完成模块开发、参与系统设计、指导初级工程师、薪资20-35K/月
│   └── 高级工程师（5-10年）：负责系统架构设计、解决技术难题、技术团队管理、薪资35-60K/月
├── 技术专家路径
│   ├── 系统架构师：系统架构设计、技术选型决策、技术风险控制、薪资50-100K/月
│   └── 技术专家：解决核心技术难题、技术方向规划、技术团队培养、薪资60-150K/月
├── 管理路径
│   ├── 工程经理：团队管理、项目管理、人员培养、薪资40-80K/月
│   ├── 产品经理：产品规划、需求分析、产品迭代、薪资30-70K/月
│   └── 项目经理：项目规划、进度控制、风险管理、薪资25-50K/月
└── AI时代职业规划
    ├── AI对职业的影响：消失的职业、新增的职业、转型的职业
    ├── AI时代核心竞争力：技术能力、协作能力、学习能力、创新能力
    └── 职业发展建议：短期目标（1-2年）、中期目标（3-5年）、长期目标（5-10年）

Part 4: 课程结束语（15分钟）
├── 感谢：感谢大家一学期的努力和付出
├── 祝福：祝愿大家在未来的职业道路上取得成功
├── 联系方式：邮箱、GitHub
└── 结课致辞
```

**实训课（2学时）**：
```
任务：项目答辩
├── 项目演示
├── 代码讲解
├── 问题回答
├── 提交项目报告
└── 提交学习心得
```

---

## 教学内容对照表

### 项目版本与教学内容对应

| 项目版本 | 时间 | 教学周次 | 教学重点 | 主要产物 |
|----------|------|----------|----------|----------|
| 草稿 | 项目初期 | 第1-4周 | UML建模、快速原型法 | 设计文档、原型代码 |
| Alpha | 功能开发 | 第5-8周 | AI辅助编码、TDD | 功能代码、测试用例 |
| Beta | 质量提升 | 第9-12周 | 分支策略、PR流程、CI/CD | 用户文档、安装程序 |
| RC1 | 发布准备 | 第13-15周 | 安全扫描、门禁检查 | 安全报告、检查清单 |
| Release/1.0 | 正式发布 | 第16周 | 版本发布、项目演示 | Release Notes |

### UML图与教学内容对应

| UML图类型 | 教学周次 | 应用场景 | AI辅助 |
|-----------|----------|----------|--------|
| 用例图 | 第2周 | 需求分析 | AI生成用例 |
| 类图 | 第3周 | 系统设计 | AI生成类结构 |
| 顺序图 | 第4周 | 流程设计 | AI生成交互流程 |
| 状态图 | 第4周 | 状态管理 | AI生成状态转换 |
| 架构图 | 第4周 | 架构设计 | AI生成架构 |
| 部署图 | 第4周 | 部署规划 | AI生成部署方案 |

---

## 考核评价体系

### 第一阶段考核（50%）

| 评价项目 | 占比 | 评价方式 |
|----------|------|----------|
| UML设计文档 | 15% | 用例图、类图、顺序图、状态图、架构图 |
| 核心模块实现 | 15% | 词法分析器、语法分析器、存储引擎 |
| 测试覆盖率 | 10% | 覆盖率≥70% |
| Alpha版本 | 10% | 功能完整性、质量门禁通过 |

### 第二阶段考核（50%）

| 评价项目 | 占比 | 评价方式 |
|----------|------|----------|
| PR流程实践 | 10% | PR创建、审核、合并流程 |
| CI/CD配置 | 10% | 流水线完整性、自动化程度 |
| Beta版本 | 10% | 用户文档、安装程序、测试计划 |
| RC1/Release | 10% | 门禁检查、安全扫描、发布流程 |
| 项目演示 | 10% | 演示质量、问题回答 |

---

**制定时间**: 2026-02-22
**更新时间**: 2026-03-01
**版本**: v3.0（重新设计：上半学期UML+设计，下半学期协同开发）
