---
marp: true
theme: gaia
paginate: true
backgroundColor: #fff
color: #333
---

<!-- _class: lead -->

# 第十二讲：性能优化与重构

## AI增强的软件工程

---

# 课程大纲

1. **性能优化概述**（25分钟）
2. **性能分析方法**（25分钟）
3. **代码重构**（25分钟）
4. **实践练习**（15分钟）

---

# Part 1: 性能优化概述

---

## 1.1 What：什么是性能优化

### 定义

通过优化代码、算法、架构等手段，提高系统的性能指标

### 性能指标

- **响应时间**：请求处理时间
- **吞吐量**：单位时间处理的请求数
- **资源利用率**：CPU、内存、磁盘、网络使用率
- **并发能力**：同时处理的请求数

---

## 1.2 Why：为什么需要性能优化

### 用户体验

- 快速响应提高用户满意度
- 降低等待时间
- 提高系统可用性

### 成本控制

- 提高资源利用率
- 降低硬件成本
- 降低运营成本

### 竞争优势

- 性能是产品竞争力
- 快速响应吸引用户
- 高并发支撑业务增长

---

## 1.3 How：性能优化层次

### 算法优化

- 选择更优的算法
- 优化时间复杂度
- 优化空间复杂度

### 代码优化

- 减少不必要的计算
- 优化数据结构
- 使用更高效的库

### 架构优化

- 缓存策略
- 负载均衡
- 分布式架构

### 系统优化

- 操作系统调优
- 数据库优化
- 网络优化

---

# Part 2: 性能分析方法

---

## 2.1 性能分析工具

### Rust性能工具

- **cargo bench**：基准测试
- **cargo flamegraph**：火焰图
- **perf**：性能分析
- **valgrind**：内存分析

### 基准测试

```rust
#[bench]
fn bench_query_execution(b: &mut Bencher) {
    let db = Database::new();
    b.iter(|| {
        db.execute("SELECT * FROM users").unwrap();
    });
}
```

---

## 2.2 性能分析流程

### 1. 建立基准

- 测量当前性能
- 设定性能目标

### 2. 识别瓶颈

- 使用性能分析工具
- 定位热点代码

### 3. 优化代码

- 针对瓶颈进行优化
- 保持代码正确性

### 4. 验证效果

- 对比优化前后性能
- 确认达到目标

---

## 2.3 SQLRustGo性能优化

### 查询优化

- 使用索引加速查询
- 优化执行计划
- 减少数据扫描

### 缓存优化

- 查询结果缓存
- 执行计划缓存
- 元数据缓存

### 并发优化

- 多线程查询执行
- 连接池管理
- 锁优化

---

# Part 3: 代码重构

---

## 3.1 What：什么是代码重构

### 定义

在不改变代码外部行为的前提下，改善代码内部结构

### 重构的目的

- 提高代码可读性
- 提高代码可维护性
- 提高代码可扩展性
- 减少技术债务

---

## 3.2 Why：为什么需要重构

### 代码质量

- 消除代码异味
- 提高代码质量
- 降低维护成本

### 技术债务

- 偿还技术债务
- 防止债务累积
- 提高开发效率

### 团队协作

- 提高代码可读性
- 降低理解成本
- 提高协作效率

---

## 3.3 How：重构方法

### 小步重构

- 每次只重构一小部分
- 保持测试通过
- 频繁提交

### 重构模式

- **提取方法**：将大方法拆分为小方法
- **提取类**：将大类拆分为小类
- **内联方法**：将小方法内联到调用处
- **移动方法**：将方法移动到合适的类

### AI辅助重构

```
分析以下代码，建议重构方案：
[代码]
要求：
1. 识别代码异味
2. 提出重构建议
3. 生成重构后的代码
```

---

## 3.4 SQLRustGo重构实践

### Parser重构

- 提取词法分析器
- 提取语法分析器
- 简化AST结构

### Storage重构

- 提取页管理器
- 提取缓冲池
- 简化存储接口

### Executor重构

- 提取执行算子
- 优化算子接口
- 简化执行流程

---

# Part 4: 实践练习

---

## 4.1 性能分析实践

### 任务

1. 编写基准测试
2. 运行性能分析
3. 识别性能瓶颈

### 示例

```rust
#[bench]
fn bench_select_query(b: &mut Bencher) {
    let db = setup_database();
    b.iter(|| {
        db.execute("SELECT * FROM users WHERE age > 18").unwrap();
    });
}
```

---

## 4.2 重构实践

### 任务

1. 识别代码异味
2. 设计重构方案
3. 执行重构

### 示例

```rust
// 重构前
fn process_query(sql: &str) -> Result<QueryResult> {
    let tokens = tokenize(sql)?;
    let ast = parse(tokens)?;
    let plan = optimize(ast)?;
    let result = execute(plan)?;
    Ok(result)
}

// 重构后
struct QueryProcessor {
    lexer: Lexer,
    parser: Parser,
    optimizer: Optimizer,
    executor: Executor,
}

impl QueryProcessor {
    fn process(&mut self, sql: &str) -> Result<QueryResult> {
        let tokens = self.lexer.tokenize(sql)?;
        let ast = self.parser.parse(tokens)?;
        let plan = self.optimizer.optimize(ast)?;
        let result = self.executor.execute(plan)?;
        Ok(result)
    }
}
```

---

# 核心知识点总结

---

## 1. 性能优化

- **What**：提高系统性能指标
- **Why**：用户体验、成本控制、竞争优势
- **How**：算法优化、代码优化、架构优化、系统优化

## 2. 性能分析

- **性能分析工具**：cargo bench、cargo flamegraph、perf
- **性能分析流程**：建立基准 → 识别瓶颈 → 优化代码 → 验证效果

## 3. 代码重构

- **What**：改善代码内部结构
- **Why**：代码质量、技术债务、团队协作
- **How**：小步重构、重构模式、AI辅助重构

---

# 课后作业

---

## 任务

1. 编写基准测试
2. 进行性能分析
3. 执行一次重构

## 预习

- 安全扫描与审计
- 依赖管理

---

<!-- _class: lead -->

# 谢谢！

## 下节课：安全扫描与审计
