---
marp: true
theme: gaia
paginate: true
backgroundColor: #fff
color: #333
---

<!-- _class: lead -->

# 第三讲：面向对象设计与类图

## AI增强的软件工程

---

# 课程大纲

1. **面向对象设计原则**（25分钟）
2. **类图**（25分钟）
3. **SQLRustGo类图设计**（25分钟）
4. **实践练习**（15分钟）

---

# Part 1: 面向对象设计原则

---

## 1.1 面向对象核心概念

### 封装（Encapsulation）

- **数据隐藏**：隐藏内部实现细节
- **接口暴露**：通过公共方法访问数据

### 继承（Inheritance）

- **代码复用**：子类继承父类的属性和方法
- **层次结构**：建立类之间的层次关系

### 多态（Polymorphism）

- **接口统一**：不同对象对同一消息有不同响应
- **运行时绑定**：在运行时确定调用的方法

---

## 1.2 SOLID原则

### 单一职责原则（SRP）

**一个类只有一个变化原因**

```rust
// ❌ 违反SRP
class User {
    fn save(&self) { }  // 数据持久化
    fn send_email(&self) { }  // 发送邮件
}

// ✅ 符合SRP
class UserRepository {
    fn save(&self, user: &User) { }
}
class EmailService {
    fn send(&self, user: &User) { }
}
```

---

## 1.2 SOLID原则（续）

### 开闭原则（OCP）

**对扩展开放，对修改关闭**

```rust
// ✅ 符合OCP
trait PaymentMethod {
    fn pay(&self, amount: f64);
}

class CreditCardPayment impl PaymentMethod { }
class AlipayPayment impl PaymentMethod { }
class WeChatPayment impl PaymentMethod { }
```

### 里氏替换原则（LSP）

**子类可以替换父类**

- 子类不应该破坏父类的行为契约
- 子类可以扩展父类，但不能改变父类的行为

---

## 1.2 SOLID原则（续）

### 接口隔离原则（ISP）

**接口要小而专一**

```rust
// ❌ 违反ISP
trait Worker {
    fn work(&self);
    fn eat(&self);
}

// ✅ 符合ISP
trait Workable {
    fn work(&self);
}
trait Eatable {
    fn eat(&self);
}
```

### 依赖倒置原则（DIP）

**依赖抽象而非具体**

- 高层模块不应该依赖低层模块
- 两者都应该依赖抽象

---

## 1.3 设计模式简介

### 创建型模式

- 单例模式、工厂模式、建造者模式

### 结构型模式

- 适配器模式、装饰器模式、代理模式

### 行为型模式

- 观察者模式、策略模式、命令模式

### AI辅助设计模式应用

- AI可以识别适合的设计模式
- AI可以生成设计模式代码
- AI可以解释设计模式的应用场景

---

# Part 2: 类图

---

## 2.1 类图的组成元素

### 类名（Class Name）

- 首字母大写
- 名词短语

### 属性（Attributes）

```
可见性 名称: 类型 = 默认值
```

- **可见性**：+public, -private, #protected
- **类型**：String, Integer, Boolean等
- **默认值**：可选

### 方法（Methods）

```
可见性 名称(参数列表): 返回类型
```

---

## 2.2 类之间的关系

### 关联（Association）

- 对象之间的连接关系
- 单向关联、双向关联
- 多重性：1, 0..1, *, 1..*

### 聚合（Aggregation）

- **has-a** 关系
- 整体与部分，部分可以独立存在
- **空心菱形**表示

### 组合（Composition）

- **contains-a** 关系
- 整体与部分，部分不能独立存在
- **实心菱形**表示

---

## 2.2 类之间的关系（续）

### 依赖（Dependency）

- **uses-a** 关系
- 一个类使用另一个类
- **虚线箭头**表示

### 泛化（Generalization）

- **is-a** 关系
- 继承关系
- **实线空心三角箭头**表示

### 实现（Realization）

- 接口实现
- **虚线空心三角箭头**表示

---

## 2.3 类图绘制规范

### 命名规范

- 类名：PascalCase（如`UserAccount`）
- 属性名：camelCase（如`userName`）
- 方法名：camelCase（如`getUserInfo`）

### 布局原则

- 从左到右、从上到下
- 父类在上，子类在下
- 相关的类靠近放置

### PlantUML语法

```plantuml
class User {
  -id: String
  -name: String
  +getId(): String
  +getName(): String
}
```

---

# Part 3: SQLRustGo类图设计

---

## 3.1 核心类设计

### 类型系统

```rust
enum Value {
    Integer(i64),
    Float(f64),
    String(String),
    Boolean(bool),
    Null,
}

enum DataType {
    Integer,
    Float,
    String,
    Boolean,
}

struct SqlError {
    message: String,
    code: u32,
}
```

---

## 3.1 核心类设计（续）

### 词法分析

```rust
enum Token {
    // 关键字
    Select, From, Where, Insert,
    // 标识符
    Identifier(String),
    // 字面量
    IntegerLiteral(i64),
    StringLiteral(String),
    // 运算符
    Plus, Minus, Star, Slash,
    Equal, NotEqual, Less, Greater,
}

struct Lexer {
    input: String,
    position: usize,
}
```

---

## 3.1 核心类设计（续）

### 语法分析

```rust
enum Statement {
    Select(SelectStatement),
    Insert(InsertStatement),
    Update(UpdateStatement),
    Delete(DeleteStatement),
    CreateTable(CreateTableStatement),
}

struct SelectStatement {
    columns: Vec<String>,
    from_table: String,
    where_clause: Option<Expression>,
    limit: Option<usize>,
}

enum Expression {
    Literal(Value),
    Column(String),
    BinaryOp {
        left: Box<Expression>,
        op: BinaryOperator,
        right: Box<Expression>,
    },
}
```

---

## 3.1 核心类设计（续）

### 存储引擎

```rust
struct Page {
    id: PageId,
    data: Vec<u8>,
    dirty: bool,
}

struct BufferPool {
    pages: HashMap<PageId, Page>,
    capacity: usize,
    lru_list: LinkedList<PageId>,
}

struct BPlusTree {
    root: Option<PageId>,
    order: usize,
}
```

---

## 3.1 核心类设计（续）

### 执行引擎

```rust
struct ExecutionEngine {
    storage: StorageEngine,
    buffer_pool: BufferPool,
}

enum ExecutionResult {
    QueryResult { columns: Vec<String>, rows: Vec<Vec<Value>> },
    UpdateResult { affected_rows: usize },
    Error(SqlError),
}
```

---

## 3.2 类关系分析

### Parser依赖关系

```
Parser → Lexer
Parser → Statement
Parser → Expression
```

### ExecutionEngine依赖关系

```
ExecutionEngine → Parser
ExecutionEngine → Storage
ExecutionEngine → ExecutionResult
```

### Statement组合关系

```
Statement ◆→ Expression
SelectStatement ◆→ Expression
```

---

## 3.3 使用AI生成类图

### 提示词设计

```
为SQLRustGo数据库系统生成类图，要求：
1. 包含核心类：Value, Token, Statement, Expression, Page, BufferPool, ExecutionEngine
2. 标注类之间的关系：依赖、关联、组合
3. 使用PlantUML语法
4. 包含关键属性和方法
```

### 迭代优化

1. AI生成初始版本
2. 人工审查类设计
3. 补充遗漏的关系
4. 优化布局和命名

---

# Part 4: 实践练习

---

## 4.1 绘制核心模块类图

### 任务

1. 选择一个核心模块
2. 识别类和关系
3. 使用PlantUML绘制

### 模块选择

- Parser模块
- Storage模块
- Executor模块

---

## 4.2 设计评审

### 评审要点

- 类职责是否单一？
- 关系是否合理？
- 是否符合SOLID原则？

### 评审方法

- 同行评审（Peer Review）
- 设计评审会议
- AI辅助评审

---

# 核心知识点总结

---

## 1. 面向对象设计

- **封装、继承、多态**
- **SOLID原则**
- **设计模式基础**

## 2. 类图

- **类的组成**：属性、方法
- **六种关系**：关联、聚合、组合、依赖、泛化、实现
- **PlantUML语法**

## 3. SQLRustGo类设计

- **核心类**：Value, Token, Statement, Page, ExecutionEngine
- **类关系分析**
- **AI辅助类图生成**

---

# 课后作业

---

## 任务

1. 完成SQLRustGo核心模块类图
2. 分析类之间的关系
3. 编写类设计文档

## 预习

- 顺序图、状态图
- 架构图、部署图

---

<!-- _class: lead -->

# 谢谢！

## 下节课：顺序图、状态图与架构设计
