---
marp: true
theme: gaia
paginate: true
backgroundColor: #fff
color: #333
---

<!-- _class: lead -->

# 第六讲：功能模块划分与接口设计

## AI增强的软件工程

---

# 课程大纲

1. **功能模块划分**（25分钟）
2. **SQLRustGo功能模块划分**（30分钟）
3. **接口设计原则与实践**（20分钟）
4. **AI辅助接口设计实践**（10分钟）

---

# Part 1: 功能模块划分

---

## 1.1 What：什么是功能模块

### 定义

功能模块是具有独立功能的软件单元，通过接口对外提供服务

### 模块的特性

- **独立性**：模块可以独立开发、测试、部署
- **可重用性**：模块可以在不同场景中重用
- **可替换性**：模块可以被其他实现替换
- **封装性**：模块隐藏内部实现细节

---

## 1.1 What：什么是功能模块（续）

### 模块的粒度

- **粗粒度模块**：功能完整、接口复杂（如存储引擎）
- **细粒度模块**：功能单一、接口简单（如词法分析器）

### 模块划分原则

- **高内聚**：模块内部元素紧密相关
- **低耦合**：模块之间依赖最小化
- **单一职责**：一个模块只负责一个功能
- **接口稳定**：模块接口应该稳定，内部实现可以变化

---

## 1.2 Why：为什么需要功能模块划分

### 复杂性管理

- 大型系统包含数百个功能
- 模块化将复杂问题分解为简单问题
- 降低认知负荷

### 团队协作

- 不同团队可以负责不同模块
- 减少代码冲突
- 提高并行开发效率

---

## 1.2 Why：为什么需要功能模块划分（续）

### 可维护性

- 模块化使代码更易理解和修改
- Bug定位更精确
- 重构范围更可控

### 可测试性

- 模块可以独立测试
- 测试覆盖率更高
- Mock和Stub更容易实现

### 可扩展性

- 新功能可以作为新模块添加
- 现有模块可以独立升级
- 支持插件化架构

---

## 1.2 Why：为什么需要功能模块划分（续）

### 业界案例

- **Linux内核**：模块化设计支持动态加载驱动
- **Chrome浏览器**：多进程架构提高稳定性
- **VS Code**：插件架构支持扩展

---

## 1.3 How：如何进行功能模块划分

### 模块划分方法

| 方法 | 依据 | 示例 | 优点 | 缺点 |
|------|------|------|------|------|
| 按功能划分 | 业务功能 | 用户管理、订单管理 | 符合业务逻辑 | 可能导致功能耦合 |
| 按层次划分 | 系统层次 | 表示层、业务层、数据层 | 结构清晰 | 跨层次调用复杂 |
| 按数据划分 | 数据实体 | 用户模块、商品模块 | 数据一致性好 | 可能产生数据冗余 |

---

## 1.3 How：如何进行功能模块划分（续）

### 模块划分流程

1. **需求分析**：识别系统功能
2. **功能聚类**：将相关功能归类
3. **模块识别**：识别候选模块
4. **接口设计**：设计模块接口
5. **依赖分析**：分析模块依赖关系
6. **迭代优化**：根据反馈优化模块划分

### 模块划分评估

- **内聚度评估**：模块内部元素的相关程度
- **耦合度评估**：模块之间的依赖程度
- **复杂度评估**：模块的复杂程度
- **可测试性评估**：模块是否易于测试

---

## 1.3 How：如何进行功能模块划分（续）

### AI辅助模块划分

```
分析以下数据库系统的需求，进行功能模块划分：
[需求文档]
要求：
1. 识别核心功能模块
2. 说明每个模块的职责
3. 分析模块之间的依赖关系
4. 评估模块划分的合理性（高内聚、低耦合）
```

---

# Part 2: SQLRustGo功能模块划分

---

## 2.1 模块划分方案

```
┌─────────────────────────────────────────────────────────┐
│                    Parser 模块                           │
│  • Lexer：词法分析器                                     │
│  • Parser：语法分析器                                    │
│  • AST：抽象语法树                                       │
│  职责：将SQL字符串转换为AST                              │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│                    Planner 模块                          │
│  • LogicalPlanner：逻辑规划器                            │
│  • PhysicalPlanner：物理规划器                           │
│  • Optimizer：查询优化器                                 │
│  职责：生成优化的执行计划                                │
└─────────────────────────────────────────────────────────┘
```

---

## 2.1 模块划分方案（续）

```
                          ↓
┌─────────────────────────────────────────────────────────┐
│                    Executor 模块                         │
│  • ExecutionEngine：执行引擎                             │
│  • Operators：执行算子                                   │
│  职责：执行查询并返回结果                                │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│                    Storage 模块                          │
│  • PageManager：页管理器                                 │
│  • BufferPool：缓冲池                                   │
│  • BPlusTree：B+树索引                                  │
│  • WAL：预写日志                                        │
│  • TransactionManager：事务管理器                        │
│  职责：数据存储、索引、事务                              │
└─────────────────────────────────────────────────────────┘
```

---

## 2.1 模块划分方案（续）

```
                          ↓
┌─────────────────────────────────────────────────────────┐
│                    Common 模块                           │
│  • Value：数据值类型                                     │
│  • DataType：数据类型枚举                                │
│  • SqlError：错误类型                                   │
│  职责：公共数据类型和工具                                │
└─────────────────────────────────────────────────────────┘
```

---

## 2.2 模块依赖关系

### 依赖方向

- **Parser → Common**：依赖公共数据类型
- **Planner → Parser, Common**：依赖AST和公共类型
- **Executor → Planner, Storage, Common**：依赖执行计划和存储层
- **Storage → Common**：依赖公共数据类型
- **所有模块 → Common**：依赖公共类型

### 依赖原则

- **上层依赖下层，下层不依赖上层**
- **避免循环依赖**
- **依赖抽象而非具体实现**

---

## 2.3 模块接口设计

### Parser模块接口

```rust
pub trait Lexer {
    fn next_token(&mut self) -> Result<Token, SqlError>;
}

pub trait Parser {
    fn parse(&mut self, sql: &str) -> Result<Statement, SqlError>;
}
```

### Planner模块接口

```rust
pub trait LogicalPlanner {
    fn plan(&self, stmt: &Statement) -> Result<LogicalPlan, SqlError>;
}

pub trait PhysicalPlanner {
    fn plan(&self, logical: &LogicalPlan) -> Result<PhysicalPlan, SqlError>;
}
```

---

## 2.3 模块接口设计（续）

### Executor模块接口

```rust
pub trait ExecutionEngine {
    fn execute(&mut self, plan: &PhysicalPlan) -> Result<ExecutionResult, SqlError>;
}
```

### Storage模块接口

```rust
pub trait PageManager {
    fn read_page(&self, page_id: PageId) -> Result<Page, SqlError>;
    fn write_page(&mut self, page: &Page) -> Result<(), SqlError>;
}

pub trait BufferPool {
    fn get_page(&mut self, page_id: PageId) -> Result<&Page, SqlError>;
    fn put_page(&mut self, page: Page) -> Result<(), SqlError>;
}
```

---

# Part 3: 接口设计原则与实践

---

## 3.1 What：什么是接口设计

### 接口的定义

模块之间交互的契约

### 接口的组成

- **方法签名**：方法名、参数、返回值
- **行为契约**：前置条件、后置条件、不变式
- **错误处理**：错误类型、错误传播

### 接口的类型

- **同步接口**：调用者等待结果
- **异步接口**：调用者不等待结果
- **流式接口**：返回数据流

---

## 3.2 Why：接口设计的重要性

### 解耦

- 接口降低模块之间的耦合度

### 可测试性

- 接口使Mock和Stub更容易实现

### 可替换性

- 接口允许替换实现而不影响调用者

### 可扩展性

- 接口支持新功能的添加

### 文档作用

- 接口本身就是文档

---

## 3.3 How：接口设计原则

### 接口隔离原则（ISP）

- 接口要小而专一
- 客户端不应该依赖它不需要的接口

### 最小知识原则（Law of Demeter）

- 模块只与直接的朋友通信
- 减少模块之间的依赖

### 契约式设计（Design by Contract）

- 明确前置条件、后置条件、不变式
- 使用类型系统保证契约

---

## 3.3 How：接口设计原则（续）

### 错误处理原则

- 使用Result类型表示可能失败的操作
- 错误类型应该包含足够的信息
- 错误应该向上传播到合适的处理层

### Rust接口设计实践

- 使用trait定义接口
- 使用泛型支持多种实现
- 使用生命周期标注引用关系
- 使用Send和Sync标记线程安全

---

# Part 4: AI辅助接口设计实践

---

## 4.1 使用AI设计接口

### 提示词设计

```
设计数据库缓冲池的接口，要求：
1. 支持获取页面：get_page(page_id)
2. 支持插入页面：put_page(page)
3. 支持LRU置换算法
4. 支持脏页标记
5. 使用Rust trait定义
6. 考虑线程安全
```

### 评估接口设计

- 接口是否简洁？
- 接口是否完整？
- 接口是否稳定？

---

## 4.2 接口评审

### 评审要点

- 接口是否简洁？
- 接口是否完整？
- 接口是否稳定？
- 错误处理是否合理？

### 评审方法

- 同行评审（Peer Review）
- 接口评审会议
- AI辅助评审

---

# 核心知识点总结

---

## 1. 功能模块划分

- **What**：功能模块的定义、特性、粒度、划分原则
- **Why**：复杂性管理、团队协作、可维护性、可测试性、可扩展性
- **How**：划分方法、划分流程、评估方法、AI辅助划分

## 2. SQLRustGo模块划分

- Parser模块、Planner模块、Executor模块、Storage模块、Common模块
- 模块依赖关系
- 模块接口设计

## 3. 接口设计

- 接口设计原则：ISP、最小知识原则、契约式设计、错误处理原则
- Rust接口设计实践
- AI辅助接口设计

---

# 课后作业

---

## 任务

1. 完成SQLRustGo模块划分文档
2. 设计所有模块的接口
3. 绘制模块依赖图

## 预习

- AI辅助开发概述
- 词法分析器实现

---

<!-- _class: lead -->

# 谢谢！

## 下节课：AI辅助核心模块实现
