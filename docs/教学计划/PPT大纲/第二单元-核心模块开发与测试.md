# 第二单元：架构设计与核心模块实现（第5-8周）

## 单元概述

| 项目 | 内容 |
|------|------|
| **单元名称** | 架构设计与核心模块实现 |
| **周次** | 第5-8周 |
| **学时** | 16学时（8理论 + 8实训） |
| **教学目标** | 掌握架构设计方法，完成核心模块开发，实现Alpha版本 |
| **对应项目阶段** | 架构设计 → 模块划分 → 核心开发 → Alpha版本 |
| **教学方法** | What-Why-How |

---

## 第5周：架构设计原理与SQLRustGo架构

### 理论课PPT大纲（2学时）

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        第5讲：架构设计原理与SQLRustGo架构                      │
│                        （PPT 40页，80分钟）                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   封面与目录（2页）                                                          │
│                                                                              │
│   Part 1: 架构设计概述（25分钟，12页）- What/Why/How                          │
│   ├── 1.1 What：什么是软件架构（4页）                                        │
│   │   ├── 定义：软件系统的高层结构                                           │
│   │   ├── 架构的层次：业务架构、应用架构、数据架构、技术架构                   │
│   │   ├── 架构的核心要素：组件、连接器、约束                                  │
│   │   └── 架构设计原则：高内聚低耦合、关注点分离、单一职责                     │
│   ├── 1.2 Why：为什么需要架构设计（4页）                                      │
│   │   ├── 复杂性管理：大型系统包含数百万行代码                                │
│   │   ├── 质量保证：架构决定系统的质量属性                                    │
│   │   ├── 团队协作：清晰的架构让多人协作成为可能                              │
│   │   ├── 风险控制：架构设计提前识别风险                                      │
│   │   └── 业界案例：Google、Netflix、微信                                    │
│   └── 1.3 How：如何进行架构设计（4页）                                        │
│       ├── 架构设计流程：需求分析→风格选择→组件设计→架构评估→迭代优化          │
│       ├── 架构风格选择：分层架构、微服务架构、事件驱动架构                    │
│       ├── 架构评估方法：ATAM、SAAM                                           │
│       └── AI辅助架构设计：提示词设计、方案评估                                │
│                                                                              │
│   Part 2: SQLRustGo四层架构设计（30分钟，14页）- What/Why/How                 │
│   ├── 2.1 What：SQLRustGo的架构设计（6页）                                    │
│   │   ├── 整体架构图                                                         │
│   │   ├── Parser Layer（解析层）：Lexer → Parser → AST                       │
│   │   ├── Planner Layer（规划层）：Logical Plan → Physical Plan              │
│   │   ├── Executor Layer（执行层）：Volcano Model → Operators                │
│   │   └── Storage Layer（存储层）：Page → BufferPool → B+Tree → WAL          │
│   ├── 2.2 Why：为什么选择四层架构（4页）                                      │
│   │   ├── 分层架构的优势：关注点分离、易于理解、易于测试、易于扩展            │
│   │   ├── 数据库系统的特性：解析层、规划层、执行层、存储层                    │
│   │   ├── 教学价值：每层对应数据库系统的核心概念                              │
│   │   └── 可扩展性：可以独立替换某一层的实现                                  │
│   └── 2.3 How：四层架构的详细设计（4页）                                      │
│       ├── Parser Layer：Lexer、Parser、AST                                   │
│       ├── Planner Layer：LogicalPlanner、PhysicalPlanner、Optimizer          │
│       ├── Executor Layer：ExecutionEngine、Operators、Volcano Model          │
│       └── Storage Layer：Page、BufferPool、BPlusTree、WAL、TransactionManager│
│                                                                              │
│   Part 3: 架构图绘制实践（20分钟，8页）                                       │
│   ├── 3.1 使用PlantUML绘制架构图（4页）                                       │
│   │   ├── PlantUML组件图语法                                                 │
│   │   ├── SQLRustGo架构图代码                                                │
│   │   └── 使用AI生成架构图代码                                               │
│   └── 3.2 架构设计评审（4页）                                                 │
│       ├── 评审要点：架构是否清晰？职责是否分离？是否易于扩展？                │
│       └── 评审方法：同行评审、架构评估会议、架构权衡分析                      │
│                                                                              │
│   Part 4: AI辅助架构设计实践（10分钟，4页）                                   │
│   ├── 4.1 使用AI生成架构方案（2页）                                          │
│   │   ├── 提示词设计                                                         │
│   │   └── 方案评估                                                           │
│   └── 4.2 使用AI生成架构图（2页）                                            │
│       ├── PlantUML代码生成                                                   │
│       └── 文档输出                                                           │
│                                                                              │
│   总结与作业（2页）                                                          │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 实训课内容（2学时）

**实训名称**：架构设计实践

**实训目标**：
- 掌握架构设计方法
- 绘制SQLRustGo架构图
- 编写架构设计文档
- 使用AI辅助架构设计

**实训步骤**：
```
步骤1: 分析架构需求（20分钟）
├── 分析SQLRustGo的功能需求
├── 识别核心组件
├── 确定组件之间的关系
└── 确定架构风格

步骤2: 绘制架构图（30分钟）
├── 使用PlantUML绘制四层架构图
├── 标注每层的核心组件
├── 标注层之间的依赖关系
└── 使用AI辅助优化

步骤3: 编写架构设计文档（25分钟）
├── 创建架构设计文档
├── 编写架构概述
├── 编写每层的设计说明
└── 编写接口设计

步骤4: Git提交（15分钟）
├── git checkout -b docs/architecture
├── git add docs/
├── git commit -m "docs: add architecture design"
└── git push origin docs/architecture
```

---

## 第6周：功能模块划分与接口设计

### 理论课PPT大纲（2学时）

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        第6讲：功能模块划分与接口设计                           │
│                        （PPT 40页，80分钟）                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   封面与目录（2页）                                                          │
│                                                                              │
│   Part 1: 功能模块划分（25分钟，12页）- What/Why/How                          │
│   ├── 1.1 What：什么是功能模块（4页）                                        │
│   │   ├── 定义：功能模块是具有独立功能的软件单元                              │
│   │   ├── 模块的特性：独立性、可重用性、可替换性、封装性                      │
│   │   ├── 模块的粒度：粗粒度模块 vs 细粒度模块                               │
│   │   └── 模块划分原则：高内聚、低耦合、单一职责、接口稳定                    │
│   ├── 1.2 Why：为什么需要功能模块划分（4页）                                  │
│   │   ├── 复杂性管理：模块化将复杂问题分解为简单问题                          │
│   │   ├── 团队协作：不同团队可以负责不同模块                                  │
│   │   ├── 可维护性：模块化使代码更易理解和修改                                │
│   │   ├── 可测试性：模块可以独立测试                                         │
│   │   └── 业界案例：Linux内核、Chrome浏览器、VS Code                         │
│   └── 1.3 How：如何进行功能模块划分（4页）                                    │
│       ├── 模块划分方法：按功能划分、按层次划分、按数据划分                    │
│       ├── 模块划分流程：需求分析→功能聚类→模块识别→接口设计→依赖分析         │
│       ├── 模块划分评估：内聚度、耦合度、复杂度、可测试性                     │
│       └── AI辅助模块划分：使用AI分析需求文档，识别功能模块                   │
│                                                                              │
│   Part 2: SQLRustGo功能模块划分（30分钟，14页）- What/Why/How                 │
│   ├── 2.1 What：SQLRustGo的模块划分方案（6页）                                │
│   │   ├── Parser模块：Lexer、Parser、AST                                     │
│   │   ├── Planner模块：LogicalPlanner、PhysicalPlanner、Optimizer            │
│   │   ├── Executor模块：ExecutionEngine、Operators                           │
│   │   ├── Storage模块：PageManager、BufferPool、BPlusTree、WAL               │
│   │   └── Common模块：Value、DataType、SqlError                              │
│   ├── 2.2 Why：为什么这样划分模块（4页）                                      │
│   │   ├── 模块依赖关系：Parser → Common, Planner → Parser                   │
│   │   ├── 依赖方向：上层依赖下层，下层不依赖上层                              │
│   │   └── 避免循环依赖                                                       │
│   └── 2.3 How：模块接口设计（4页）                                           │
│       ├── Parser模块接口：Lexer trait, Parser trait                         │
│       ├── Planner模块接口：LogicalPlanner trait, PhysicalPlanner trait      │
│       ├── Executor模块接口：ExecutionEngine trait                           │
│       └── Storage模块接口：PageManager trait, BufferPool trait              │
│                                                                              │
│   Part 3: 接口设计原则与实践（20分钟，8页）- What/Why/How                      │
│   ├── 3.1 What：什么是接口设计（2页）                                        │
│   │   ├── 接口的定义：模块之间交互的契约                                      │
│   │   └── 接口的组成：方法签名、行为契约、错误处理                            │
│   ├── 3.2 Why：接口设计的重要性（2页）                                       │
│   │   ├── 解耦、可测试性、可替换性、可扩展性、文档作用                        │
│   └── 3.3 How：接口设计原则（4页）                                           │
│       ├── 接口隔离原则（ISP）                                                │
│       ├── 最小知识原则（Law of Demeter）                                     │
│       ├── 契约式设计（Design by Contract）                                   │
│       └── Rust接口设计实践：trait、泛型、生命周期                            │
│                                                                              │
│   Part 4: AI辅助接口设计实践（10分钟，4页）                                   │
│   ├── 4.1 使用AI设计接口（2页）                                              │
│   │   ├── 提示词设计                                                         │
│   │   └── 评估接口设计                                                       │
│   └── 4.2 接口评审（2页）                                                    │
│       ├── 评审要点：接口是否简洁？完整？稳定？                               │
│       └── 评审方法：同行评审、AI辅助评审                                     │
│                                                                              │
│   总结与作业（2页）                                                          │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 实训课内容（2学时）

**实训名称**：模块划分与接口设计

**实训目标**：
- 掌握模块划分方法
- 完成SQLRustGo模块划分
- 设计模块接口
- 使用AI辅助接口设计

**实训步骤**：
```
步骤1: 分析模块划分（20分钟）
├── 分析SQLRustGo的功能需求
├── 识别核心模块
├── 分析模块之间的依赖关系
└── 绘制模块依赖图

步骤2: 设计模块接口（30分钟）
├── 设计Parser模块接口
├── 设计Planner模块接口
├── 设计Executor模块接口
├── 设计Storage模块接口
└── 使用AI辅助设计

步骤3: 编写模块设计文档（25分钟）
├── 创建模块设计文档
├── 编写模块划分说明
├── 编写接口定义
└── 编写依赖关系说明

步骤4: Git提交（15分钟）
├── git checkout -b docs/modules
├── git add docs/
├── git commit -m "docs: add module design"
└── git push origin docs/modules
```

---

## 第7周：AI辅助核心模块实现

### 理论课PPT大纲（2学时）

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        第7讲：AI辅助核心模块实现                               │
│                        （PPT 40页，80分钟）                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   封面与目录（2页）                                                          │
│                                                                              │
│   Part 1: AI辅助开发概述（20分钟，10页）- What/Why/How                        │
│   ├── 1.1 What：AI辅助开发是什么（3页）                                      │
│   │   ├── 定义：使用AI工具辅助软件开发的各个环节                              │
│   │   ├── AI辅助开发的阶段：需求分析、设计、编码、测试、文档                  │
│   │   └── AI辅助开发工具：AI-IDE、AI编程助手、AI聊天机器人、AI代码审查        │
│   ├── 1.2 Why：为什么使用AI辅助开发（3页）                                    │
│   │   ├── 提高效率：开发效率提升2-5倍                                        │
│   │   ├── 降低门槛：新手可以借助AI快速上手                                   │
│   │   ├── 提高质量：AI可以生成规范的代码                                     │
│   │   └── 业界案例：GitHub Copilot提高55%编码速度                            │
│   └── 1.3 How：如何有效使用AI辅助开发（4页）                                  │
│       ├── AI辅助开发流程：明确需求→设计提示词→生成代码→代码审查→测试验证     │
│       ├── 提示词工程：清晰性、完整性、结构性、可迭代性                        │
│       ├── 代码审查要点：正确性、安全性、性能、可读性、可维护性                │
│       └── AI辅助开发的局限性：上下文窗口限制、创造性限制、领域知识限制        │
│                                                                              │
│   Part 2: AI辅助实现词法分析器（30分钟，12页）- What/Why/How                  │
│   ├── 2.1 What：词法分析原理（4页）                                          │
│   │   ├── 词法分析的作用：将SQL字符串转换为Token流                            │
│   │   ├── Token类型：关键字、标识符、字面量、运算符、分隔符                   │
│   │   ├── 正则表达式：描述Token的模式                                        │
│   │   └── 有限状态机（FSM）：实现词法分析器                                   │
│   ├── 2.2 Why：为什么使用AI辅助实现（2页）                                    │
│   │   ├── 快速生成样板代码                                                   │
│   │   └── 减少重复工作                                                       │
│   └── 2.3 How：使用AI实现词法分析器（6页）                                    │
│       ├── 提示词设计：生成Token定义                                          │
│       ├── 提示词设计：生成词法分析器                                         │
│       ├── 代码审查：检查逻辑正确性、错误处理、边界条件                        │
│       └── 测试验证：编写测试用例、验证功能                                   │
│                                                                              │
│   Part 3: AI辅助实现语法分析器（20分钟，10页）- What/Why/How                  │
│   ├── 3.1 What：语法分析原理（4页）                                          │
│   │   ├── 语法分析的作用：将Token流转换为AST                                 │
│   │   ├── 上下文无关文法：描述SQL语法                                        │
│   │   ├── 抽象语法树（AST）：表示SQL语句的结构                               │
│   │   └── 递归下降解析：实现语法分析器                                       │
│   ├── 3.2 Why：为什么使用AI辅助实现（2页）                                    │
│   │   ├── 语法规则复杂，AI可以快速生成                                       │
│   │   └── 错误处理繁琐，AI可以生成完善的错误处理                              │
│   └── 3.3 How：使用AI实现语法分析器（4页）                                    │
│       ├── 提示词设计：生成AST定义                                            │
│       ├── 提示词设计：生成语法分析器                                         │
│       └── 测试验证                                                           │
│                                                                              │
│   Part 4: AI辅助实现存储引擎（20分钟，6页）- What/Why/How                     │
│   ├── 4.1 What：存储引擎原理（2页）                                          │
│   │   ├── 页式存储、缓冲池、B+树索引、WAL日志                                │
│   └── 4.2 How：使用AI实现存储引擎（4页）                                      │
│       ├── 提示词设计：设计页结构                                             │
│       ├── 提示词设计：实现缓冲池                                             │
│       └── 测试验证                                                           │
│                                                                              │
│   总结与作业（2页）                                                          │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 实训课内容（2学时）

**实训名称**：核心模块实现

**实训目标**：
- 使用AI实现词法分析器
- 使用AI实现语法分析器
- 使用AI实现存储引擎基础
- 编写测试用例

**实训步骤**：
```
步骤1: 使用AI实现词法分析器（30分钟）
├── 设计Token类型
├── 使用AI生成Token定义
├── 使用AI生成词法分析器
├── 代码审查
└── 测试验证

步骤2: 使用AI实现语法分析器（30分钟）
├── 设计AST结构
├── 使用AI生成AST定义
├── 使用AI生成语法分析器
├── 代码审查
└── 测试验证

步骤3: 使用AI实现存储引擎基础（20分钟）
├── 设计页结构
├── 使用AI生成页结构代码
├── 使用AI生成缓冲池代码
└── 测试验证

步骤4: Git提交（10分钟）
├── git checkout -b feature/core-modules
├── git add src/
├── git commit -m "feat: implement core modules"
└── git push origin feature/core-modules
```

---

## 第8周：测试驱动开发与Alpha版本

### 理论课PPT大纲（2学时）

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        第8讲：测试驱动开发与Alpha版本                          │
│                        （PPT 40页，80分钟）                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   封面与目录（2页）                                                          │
│                                                                              │
│   Part 1: 测试驱动开发（TDD）（25分钟，12页）- What/Why/How                    │
│   ├── 1.1 What：TDD的核心思想（4页）                                         │
│   │   ├── 测试先行：先写测试，再写代码                                       │
│   │   ├── 快速反馈：测试立即反馈代码是否正确                                 │
│   │   ├── 持续重构：在测试保护下重构代码                                     │
│   │   └── Red-Green-Refactor循环                                            │
│   ├── 1.2 Why：测试先行的好处（4页）                                         │
│   │   ├── 更好的设计：从使用者角度设计接口                                   │
│   │   ├── 更高的测试覆盖率：每个功能都有对应的测试                           │
│   │   ├── 更少的Bug：测试捕获大部分Bug                                       │
│   │   └── 文档作用：测试就是活文档                                           │
│   └── 1.3 How：TDD实践技巧（4页）                                            │
│       ├── 从简单测试开始                                                     │
│       ├── 保持测试独立                                                       │
│       ├── 测试命名规范                                                       │
│       └── 使用AI辅助TDD                                                      │
│                                                                              │
│   Part 2: AI辅助测试生成（25分钟，12页）- What/Why/How                        │
│   ├── 2.1 What：使用AI生成测试用例（4页）                                    │
│   │   ├── 提示词设计：为词法分析器生成测试用例                               │
│   │   ├── AI输出示例                                                        │
│   │   └── 人工审查                                                           │
│   ├── 2.2 Why：使用AI辅助测试（4页）                                         │
│   │   ├── 快速生成测试用例                                                   │
│   │   ├── 发现边界条件                                                       │
│   │   ├── 提高测试覆盖率                                                     │
│   │   └── 减少重复工作                                                       │
│   └── 2.3 How：AI辅助测试流程（4页）                                         │
│       ├── 使用AI生成测试用例                                                │
│       ├── 使用AI分析测试覆盖率                                              │
│       ├── 使用AI发现边界条件                                                │
│       └── 实例：SQLRustGo测试                                               │
│                                                                              │
│   Part 3: Rust测试框架（15分钟，6页）                                         │
│   ├── 3.1 #[test] 属性（2页）                                                │
│   ├── 3.2 assert! 宏系列（2页）                                              │
│   │   ├── assert!, assert_eq!, assert_ne!                                   │
│   └── 3.3 测试覆盖率工具（2页）                                              │
│       ├── cargo-tarpaulin, cargo-llvm-cov                                   │
│                                                                              │
│   Part 4: Alpha版本验收（20分钟，8页）                                        │
│   ├── 4.1 Alpha版本定义（2页）                                               │
│   │   ├── 功能完整性、可运行、有测试、有文档                                 │
│   ├── 4.2 功能验收标准（2页）                                                │
│   │   ├── SQL解析：支持SELECT、INSERT、UPDATE、DELETE、CREATE TABLE          │
│   │   ├── 存储引擎：支持数据读写、页管理、缓冲池                             │
│   │   └── 执行引擎：支持基本查询执行                                         │
│   ├── 4.3 质量门禁（2页）                                                    │
│   │   ├── 编译通过、测试通过、Clippy无警告、格式化通过、覆盖率≥70%           │
│   └── 4.4 Alpha版本发布（2页）                                               │
│       ├── 创建版本标签                                                       │
│       └── 编写Release Notes                                                 │
│                                                                              │
│   总结与作业（2页）                                                          │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 实训课内容（2学时）

**实训名称**：Alpha版本完成

**实训目标**：
- 补充单元测试
- 提高测试覆盖率至70%+
- 运行所有质量检查
- 完成Alpha版本

**实训步骤**：
```
步骤1: 补充单元测试（30分钟）
├── 分析测试覆盖率
├── 使用AI生成测试用例
├── 补充缺失的测试
└── 运行测试验证

步骤2: 提高测试覆盖率（20分钟）
├── 运行覆盖率工具
├── 分析覆盖率报告
├── 补充测试用例
└── 达到70%+覆盖率

步骤3: 运行质量检查（20分钟）
├── cargo build
├── cargo test
├── cargo clippy
├── cargo fmt --check
└── 修复发现的问题

步骤4: Git提交Alpha版本（10分钟）
├── git checkout -b release/alpha
├── git add .
├── git commit -m "release: alpha version"
├── git tag v0.1.0-alpha
└── git push origin release/alpha --tags
```

---

## 单元总结

### 知识点回顾

| 周次 | 理论知识 | 实践技能 | 项目产出 |
|------|----------|----------|----------|
| 5 | 架构设计原理、SQLRustGo四层架构 | 架构图绘制 | 架构文档 |
| 6 | 功能模块划分、接口设计原则 | 模块接口设计 | 模块文档 |
| 7 | AI辅助开发、词法分析、语法分析、存储引擎 | 核心模块实现 | 核心模块 |
| 8 | TDD、测试覆盖率、Alpha验收 | 测试编写 | Alpha版本 |

### 能力培养目标

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        第二单元能力培养                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   架构设计能力                                                               │
│   ────────────                                                               │
│   • 理解软件架构的概念和原则                                                 │
│   • 掌握架构设计流程和方法                                                   │
│   • 能够进行架构评估和优化                                                   │
│                                                                              │
│   模块设计能力                                                               │
│   ────────────                                                               │
│   • 掌握功能模块划分方法                                                     │
│   • 掌握接口设计原则                                                         │
│   • 能够进行模块依赖分析                                                     │
│                                                                              │
│   AI辅助开发能力                                                             │
│   ────────────────                                                           │
│   • 掌握提示词工程基础                                                       │
│   • 能够使用AI生成代码和测试                                                 │
│   • 能够审查和优化AI生成的代码                                               │
│                                                                              │
│   测试能力                                                                   │
│   ────────                                                                   │
│   • 掌握测试驱动开发方法                                                     │
│   • 掌握Rust测试框架                                                         │
│   • 能够编写规范的测试用例                                                   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

**制定时间**: 2026-02-22  
**更新时间**: 2026-03-02  
**版本**: v3.0（采用What-Why-How教学法）
