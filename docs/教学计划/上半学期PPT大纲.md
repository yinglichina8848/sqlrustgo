# 上半学期PPT大纲（第1-8周）

## 第一讲：软件工程概述与项目导论（第1周）

### PPT结构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        第一讲：软件工程概述与项目导论                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Part 1: 软件工程发展历史（25分钟）                                          │
│   ─────────────────────────────                                              │
│   1.1 软件工程的诞生                                                         │
│       • 1968年 NATO会议 - "软件危机"的提出                                   │
│       • 从"编程"到"工程"的转变                                               │
│       • 软件工程定义的演变                                                   │
│                                                                              │
│   1.2 软件工程的发展阶段                                                     │
│       • 1968-1980: 结构化编程时代                                            │
│         - Dijkstra的"goto有害论"                                             │
│         - 结构化分析设计方法                                                 │
│         - 瀑布模型的建立                                                     │
│       • 1980-2000: 面向对象时代                                              │
│         - Smalltalk、C++、Java的兴起                                         │
│         - UML统一建模语言                                                    │
│         - 设计模式运动                                                       │
│       • 2000-2020: 敏捷与DevOps时代                                          │
│         - 敏捷宣言（2001）                                                   │
│         - Scrum、Kanban等方法论                                              │
│         - CI/CD、DevOps实践                                                  │
│       • 2020-现在: AI增强时代                                                │
│         - GitHub Copilot（2021）                                             │
│         - ChatGPT（2022）                                                    │
│         - Claude Code、Cursor等AI-IDE（2024-2025）                           │
│                                                                              │
│   1.3 软件工程的适用领域与成就                                               │
│       • 适用领域                                                             │
│         - 企业级应用（ERP、CRM、银行系统）                                    │
│         - 互联网服务（电商、社交、搜索）                                      │
│         - 嵌入式系统（汽车、医疗设备）                                        │
│         - 科学计算与数据分析                                                 │
│       • 重大成就                                                             │
│         - 大型系统成功案例（Linux、Chrome、TensorFlow）                       │
│         - 软件质量的大幅提升                                                 │
│         - 开发效率的指数级增长                                               │
│         - 开源生态的繁荣                                                     │
│                                                                              │
│   Part 2: Greenfield与Brownfield项目（20分钟）                                │
│   ─────────────────────────────────                                          │
│   2.1 Greenfield（绿地项目）                                                 │
│       • 定义：从零开始构建的新项目                                           │
│       • 特点：                                                               │
│         - 无历史包袱，技术选型自由                                           │
│         - 需求明确时效率极高                                                 │
│         - 适合新技术探索和验证                                               │
│       • 典型案例：                                                           │
│         - 新创公司的MVP产品                                                  │
│         - 新技术验证项目                                                     │
│         - SQLRustGo项目（本课程案例）                                        │
│       • 代码规模：通常 1K-50K 行代码                                         │
│                                                                              │
│   2.2 Brownfield（棕地项目）                                                 │
│       • 定义：在现有系统上修改和扩展                                          │
│       • 特点：                                                               │
│         - 需要理解遗留代码                                                   │
│         - 技术债务处理                                                       │
│         - 渐进式重构和迁移                                                   │
│       • 典型案例：                                                           │
│         - 银行核心系统升级                                                   │
│         - 大型互联网平台迭代                                                 │
│         - 遗留系统现代化                                                     │
│       • 代码规模：通常 100K-10M+ 行代码                                      │
│                                                                              │
│   2.3 项目类型对比                                                           │
│       ┌─────────────────────────────────────────────────────────────┐        │
│       │ 维度         │ Greenfield        │ Brownfield             │        │
│       ├─────────────────────────────────────────────────────────────┤        │
│       │ 起点         │ 空白              │ 现有代码库             │        │
│       │ 技术选型     │ 完全自由          │ 受限于现有架构         │        │
│       │ 认知负荷     │ 较低              │ 较高                   │        │
│       │ 风险类型     │ 需求风险          │ 集成风险               │        │
│       │ AI辅助效果   │ 显著              │ 需要更多上下文         │        │
│       └─────────────────────────────────────────────────────────────┘        │
│                                                                              │
│   Part 3: AI对软件工程的影响（25分钟）                                        │
│   ─────────────────────────────────                                          │
│   3.1 大语言模型（LLM）的突破                                                │
│       • 技术里程碑                                                           │
│         - GPT-3（2020）：代码生成能力初现                                    │
│         - Codex（2021）：专门优化的代码模型                                  │
│         - GPT-4（2023）：复杂推理能力                                        │
│         - Claude 3.5/4（2024-2025）：长上下文、深度推理                      │
│       • 核心能力                                                             │
│         - 代码生成与补全                                                     │
│         - 代码解释与分析                                                     │
│         - 自然语言编程                                                       │
│         - 文档生成与翻译                                                     │
│                                                                              │
│   3.2 AI-IDE工具演进                                                         │
│       • 第一代：代码补全                                                     │
│         - TabNine、Kite（2019-2020）                                         │
│         - 基于统计的补全                                                     │
│       • 第二代：AI辅助                                                       │
│         - GitHub Copilot（2021）                                             │
│         - 实时代码建议                                                       │
│       • 第三代：AI原生IDE                                                    │
│         - Cursor（2023）                                                     │
│         - TRAE IDE（2024）                                                   │
│         - 全项目上下文理解                                                   │
│       • 第四代：自主Agent                                                    │
│         - Claude Code（2024）                                                │
│         - 自主规划、执行、调试                                               │
│                                                                              │
│   3.3 AI Coding的局限性与适用范围                                            │
│       • 上下文窗口限制                                                       │
│         - Claude: 200K tokens（约15万行代码）                                │
│         - 实际有效范围：20-40%容量后性能下降                                 │
│       • AI增强SE适合的项目规模                                               │
│         - 小型（<10K行）：★★★★★ 全AI辅助开发                              │
│         - 中型（10K-50K行）：★★★★☆ AI+人工审查                            │
│         - 大型（50K-200K行）：★★★☆☆ 模块级AI辅助                          │
│       • AI增强SE适合的项目类型                                               │
│         - 最适合：Greenfield项目、API/SDK开发、工具类软件                    │
│         - 需谨慎：核心业务逻辑、安全关键系统                                 │
│                                                                              │
│   Part 4: SQLRustGo项目导论（20分钟）                                         │
│   ───────────────────────────────                                            │
│   4.1 项目背景和目标                                                         │
│       • 为什么选择数据库项目？                                               │
│       • 为什么选择 Rust？                                                    │
│       • 项目目标和应用场景                                                   │
│                                                                              │
│   4.2 项目版本历程概览                                                       │
│       • 草稿 → Alpha → Beta → RC → Release                                  │
│       • 每个版本的特征和产物                                                 │
│       • 作为Greenfield项目的典型案例                                         │
│                                                                              │
│   4.3 课程安排说明                                                           │
│       • 上半学期：AI辅助设计与快速原型                                       │
│       • 下半学期：协同开发与工程治理                                         │
│       • 考核方式：过程性评价70% + 终结性评价30%                              │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 核心知识点

1. **软件工程发展脉络**
   - 从"软件危机"到"工程化"
   - 结构化 → 面向对象 → 敏捷 → AI增强
   - AI是新的生产力工具，不是替代

2. **Greenfield vs Brownfield**
   - Greenfield：新项目，自由度高，AI效果好
   - Brownfield：遗留系统，认知负荷高，AI需更多上下文
   - 本课程项目属于Greenfield类型

3. **AI Coding的边界**
   - 上下文窗口是硬限制
   - 适合中小型项目（<50K行）
   - Greenfield项目效果最佳
   - 人类审查和决策不可替代

### 课堂互动

- 讨论：你认为软件开发中最大的挑战是什么？
- 思考：你使用过哪些AI编程工具？效果如何？
- 分析：SQLRustGo属于什么类型的项目？为什么适合AI辅助开发？
- 预习：安装Rust环境和TRAE IDE

### 课后阅读

1. 《人月神话》- Frederick Brooks（软件工程经典）
2. 《敏捷软件开发宣言》（2001）
3. GitHub Copilot官方文档
4. Claude Code使用指南

---

## 第二讲：结构化设计与UML基础（第2周）

### PPT结构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        第二讲：结构化设计与UML基础                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Part 1: 结构化设计方法（25分钟）                                            │
│   ─────────────────────────────                                              │
│   1.1 结构化设计的历史背景                                                   │
│       • 1960-1970年代的软件危机                                              │
│       • Dijkstra的贡献                                                       │
│       • "Go To Statement Considered Harmful"（1968）                         │
│                                                                              │
│   1.2 核心思想                                                               │
│       • 自顶向下、逐步求精                                                   │
│       • 模块化设计原则                                                       │
│         - 高内聚、低耦合                                                     │
│         - 信息隐藏                                                           │
│         - 模块独立性                                                         │
│                                                                              │
│   1.3 结构化分析与设计工具                                                   │
│       • 数据流图（DFD）                                                      │
│         - 外部实体                                                           │
│         - 处理过程                                                           │
│         - 数据存储                                                           │
│         - 数据流                                                             │
│       • 数据字典                                                             │
│       • 结构图                                                               │
│                                                                              │
│   1.4 结构化设计的优缺点                                                     │
│       • 优点：清晰、系统、可追溯                                             │
│       • 缺点：刚性、不适应变化                                               │
│       • 对AI辅助开发的启示                                                   │
│                                                                              │
│   Part 2: UML概述（25分钟）                                                   │
│   ─────────────────────                                                      │
│   2.1 UML的历史和发展                                                        │
│       • 面向对象方法论的统一                                                 │
│       • UML 1.x → UML 2.x                                                    │
│       • UML在软件工程中的地位                                                │
│                                                                              │
│   2.2 UML 2.0 分类                                                           │
│       • 结构图（Structure Diagrams）                                         │
│         - 类图（Class Diagram）                                              │
│         - 对象图（Object Diagram）                                           │
│         - 组件图（Component Diagram）                                        │
│         - 部署图（Deployment Diagram）                                       │
│       • 行为图（Behavior Diagrams）                                          │
│         - 用例图（Use Case Diagram）                                         │
│         - 顺序图（Sequence Diagram）                                         │
│         - 活动图（Activity Diagram）                                         │
│         - 状态图（State Diagram）                                            │
│                                                                              │
│   2.3 UML工具介绍                                                            │
│       • PlantUML（文本到图形）                                               │
│         - 优点：版本控制友好、AI易生成                                       │
│         - 基本语法                                                           │
│       • Draw.io / diagrams.net                                               │
│       • StarUML / Enterprise Architect                                       │
│       • AI辅助UML绘图                                                        │
│                                                                              │
│   Part 3: 用例图（25分钟）                                                    │
│   ─────────────────────                                                      │
│   3.1 用例图的组成元素                                                       │
│       • 参与者（Actor）                                                      │
│         - 用户角色                                                           │
│         - 外部系统                                                           │
│       • 用例（Use Case）                                                     │
│         - 功能描述                                                           │
│         - 命名规范                                                           │
│       • 系统边界（System Boundary）                                          │
│                                                                              │
│   3.2 用例之间的关系                                                         │
│       • 关联（Association）                                                  │
│       • 包含（Include）                                                      │
│       • 扩展（Extend）                                                       │
│       • 泛化（Generalization）                                               │
│                                                                              │
│   3.3 实例：SQLRustGo用例图                                                  │
│       • 参与者识别                                                           │
│         - 数据库用户                                                         │
│         - 管理员                                                             │
│         - 客户端程序                                                         │
│       • 用例识别                                                             │
│         - 连接数据库                                                         │
│         - 执行SQL查询                                                        │
│         - 管理表结构                                                         │
│         - 事务处理                                                           │
│       • 使用AI生成用例图                                                     │
│         - 提示词设计                                                         │
│         - PlantUML代码生成                                                   │
│                                                                              │
│   Part 4: 实践练习（15分钟）                                                  │
│   ─────────────────────                                                      │
│   4.1 绘制SQLRustGo用例图                                                    │
│       • 使用PlantUML语法                                                     │
│       • AI辅助优化                                                           │
│                                                                              │
│   4.2 编写用例描述                                                           │
│       • 用例名称                                                             │
│       • 参与者                                                               │
│       • 前置条件                                                             │
│       • 主成功场景                                                           │
│       • 后置条件                                                             │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 核心知识点

1. **结构化设计**
   - 自顶向下、逐步求精
   - 高内聚、低耦合
   - 数据流图（DFD）的应用

2. **UML基础**
   - UML 2.0 分类：结构图 vs 行为图
   - PlantUML文本化建模
   - AI辅助UML绘图

3. **用例图**
   - 参与者、用例、系统边界
   - 包含、扩展、泛化关系
   - 用例描述规范

### 课堂互动

- 练习：绘制SQLRustGo用例图
- 讨论：结构化设计在AI时代还有价值吗？
- 实践：使用AI生成PlantUML代码

### 课后作业

1. 完成SQLRustGo用例图（至少5个用例）
2. 编写2个核心用例的详细描述
3. 阅读PlantUML官方文档

---

## 第三讲：面向对象设计与类图（第3周）

### PPT结构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        第三讲：面向对象设计与类图                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Part 1: 面向对象设计原则（25分钟）                                          │
│   ─────────────────────────────                                              │
│   1.1 面向对象核心概念                                                       │
│       • 封装（Encapsulation）                                                │
│         - 数据隐藏                                                           │
│         - 接口暴露                                                           │
│       • 继承（Inheritance）                                                  │
│         - 代码复用                                                           │
│         - 层次结构                                                           │
│       • 多态（Polymorphism）                                                 │
│         - 接口统一                                                           │
│         - 运行时绑定                                                         │
│                                                                              │
│   1.2 SOLID原则                                                              │
│       • 单一职责原则（SRP）                                                  │
│         - 一个类只有一个变化原因                                             │
│       • 开闭原则（OCP）                                                      │
│         - 对扩展开放，对修改关闭                                             │
│       • 里氏替换原则（LSP）                                                  │
│         - 子类可以替换父类                                                   │
│       • 接口隔离原则（ISP）                                                  │
│         - 接口要小而专一                                                     │
│       • 依赖倒置原则（DIP）                                                  │
│         - 依赖抽象而非具体                                                   │
│                                                                              │
│   1.3 设计模式简介                                                           │
│       • 创建型模式                                                           │
│       • 结构型模式                                                           │
│       • 行为型模式                                                           │
│       • AI辅助设计模式应用                                                   │
│                                                                              │
│   Part 2: 类图（25分钟）                                                      │
│   ─────────────────────                                                      │
│   2.1 类图的组成元素                                                         │
│       • 类名（Class Name）                                                   │
│       • 属性（Attributes）                                                   │
│         - 可见性：+public, -private, #protected                              │
│         - 类型                                                               │
│         - 默认值                                                             │
│       • 方法（Methods）                                                      │
│         - 可见性                                                             │
│         - 参数列表                                                           │
│         - 返回类型                                                           │
│                                                                              │
│   2.2 类之间的关系                                                           │
│       • 关联（Association）                                                  │
│         - 单向关联                                                           │
│         - 双向关联                                                           │
│         - 多重性                                                             │
│       • 聚合（Aggregation）                                                  │
│         - has-a 关系                                                         │
│         - 空心菱形                                                           │
│       • 组合（Composition）                                                  │
│         - contains-a 关系                                                    │
│         - 实心菱形                                                           │
│       • 依赖（Dependency）                                                   │
│         - uses-a 关系                                                        │
│         - 虚线箭头                                                           │
│       • 泛化（Generalization）                                               │
│         - is-a 关系                                                          │
│         - 继承                                                               │
│       • 实现（Realization）                                                  │
│         - 接口实现                                                           │
│                                                                              │
│   2.3 类图绘制规范                                                           │
│       • 命名规范                                                             │
│       • 布局原则                                                             │
│       • PlantUML语法                                                         │
│                                                                              │
│   Part 3: SQLRustGo类图设计（25分钟）                                         │
│   ───────────────────────────────                                            │
│   3.1 核心类设计                                                             │
│       • 类型系统                                                             │
│         - Value（数据值类型）                                                │
│         - DataType（数据类型枚举）                                           │
│         - SqlError（错误类型）                                               │
│       • 词法分析                                                             │
│         - Token（词法单元）                                                  │
│         - Lexer（词法分析器）                                                │
│       • 语法分析                                                             │
│         - Statement（SQL语句AST）                                            │
│         - Expression（表达式）                                               │
│         - Parser（语法分析器）                                               │
│       • 存储引擎                                                             │
│         - Page（存储页）                                                     │
│         - BufferPool（缓冲池）                                               │
│         - BPlusTree（B+树索引）                                              │
│       • 执行引擎                                                             │
│         - ExecutionEngine（执行引擎）                                        │
│         - ExecutionResult（执行结果）                                        │
│                                                                              │
│   3.2 类关系分析                                                             │
│       • Parser 依赖 Lexer                                                    │
│       • ExecutionEngine 依赖 Parser, Storage                                 │
│       • Statement 包含 Expression                                            │
│                                                                              │
│   3.3 使用AI生成类图                                                         │
│       • 提示词设计                                                           │
│       • PlantUML代码生成                                                     │
│       • 迭代优化                                                             │
│                                                                              │
│   Part 4: 实践练习（15分钟）                                                  │
│   ─────────────────────                                                      │
│   4.1 绘制核心模块类图                                                       │
│       • 选择一个核心模块                                                     │
│       • 识别类和关系                                                         │
│       • 使用PlantUML绘制                                                     │
│                                                                              │
│   4.2 设计评审                                                               │
│       • 类职责是否单一？                                                     │
│       • 关系是否合理？                                                       │
│       • 是否符合SOLID原则？                                                  │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 核心知识点

1. **面向对象设计**
   - 封装、继承、多态
   - SOLID原则
   - 设计模式基础

2. **类图**
   - 类的组成：属性、方法
   - 六种关系：关联、聚合、组合、依赖、泛化、实现
   - PlantUML语法

3. **SQLRustGo类设计**
   - 核心类：Value, Token, Statement, Page, ExecutionEngine
   - 类关系分析
   - AI辅助类图生成

### 课堂互动

- 练习：绘制SQLRustGo核心类图
- 讨论：聚合和组合有什么区别？
- 实践：使用AI生成类图并优化

### 课后作业

1. 完成SQLRustGo核心模块类图
2. 分析类之间的关系
3. 编写类设计文档

---

## 第四讲：顺序图、状态图与架构设计（第4周）

### PPT结构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        第四讲：顺序图、状态图与架构设计                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Part 1: 顺序图（20分钟）                                                    │
│   ─────────────────────                                                      │
│   1.1 顺序图的组成元素                                                       │
│       • 对象（Object）/ 参与者                                               │
│       • 生命线（Lifeline）                                                   │
│       • 消息（Message）                                                      │
│         - 同步消息                                                           │
│         - 异步消息                                                           │
│         - 返回消息                                                           │
│       • 激活（Activation）                                                   │
│       • 组合片段（Combined Fragment）                                        │
│         - alt（条件分支）                                                    │
│         - loop（循环）                                                       │
│         - opt（可选）                                                        │
│                                                                              │
│   1.2 顺序图绘制规范                                                         │
│       • 从左到右排列对象                                                     │
│       • 消息从上到下按时间顺序                                               │
│       • 命名清晰                                                             │
│                                                                              │
│   1.3 实例：SQL查询执行顺序图                                                │
│       • 参与者：Client, Parser, Executor, Storage                            │
│       • 消息流程：                                                           │
│         1. Client → Parser: parse(sql)                                      │
│         2. Parser → Client: Statement                                       │
│         3. Client → Executor: execute(Statement)                            │
│         4. Executor → Storage: read(table)                                  │
│         5. Storage → Executor: rows                                         │
│         6. Executor → Client: Result                                        │
│       • 使用AI生成顺序图                                                     │
│                                                                              │
│   Part 2: 状态图（20分钟）                                                    │
│   ─────────────────────                                                      │
│   2.1 状态图的组成元素                                                       │
│       • 状态（State）                                                        │
│         - 初始状态                                                           │
│         - 终止状态                                                           │
│         - 中间状态                                                           │
│       • 转换（Transition）                                                   │
│         - 触发事件                                                           │
│         - 转换条件                                                           │
│       • 事件（Event）                                                        │
│       • 动作（Action）                                                       │
│                                                                              │
│   2.2 状态图绘制规范                                                         │
│       • 状态命名清晰                                                         │
│       • 转换条件明确                                                         │
│       • 避免状态爆炸                                                         │
│                                                                              │
│   2.3 实例：事务状态图                                                       │
│       • 状态：Idle → Active → Committed / Rolledback                        │
│       • 转换：                                                               │
│         - Idle → Active: BEGIN                                              │
│         - Active → Committed: COMMIT                                        │
│         - Active → Rolledback: ROLLBACK                                     │
│       • 使用AI生成状态图                                                     │
│                                                                              │
│   Part 3: 架构图与部署图（25分钟）                                            │
│   ─────────────────────────────                                              │
│   3.1 架构图类型                                                             │
│       • 分层架构图                                                           │
│       • 模块架构图                                                           │
│       • 组件架构图                                                           │
│                                                                              │
│   3.2 SQLRustGo四层架构                                                      │
│       ┌─────────────────────────────────────────────────────────────┐        │
│       │                    SQLRustGo 架构                            │        │
│       ├─────────────────────────────────────────────────────────────┤        │
│       │  ┌─────────────────────────────────────────────────────┐    │        │
│       │  │                    Parser Layer                      │    │        │
│       │  │         Lexer → Parser → AST                         │    │        │
│       │  └─────────────────────────────────────────────────────┘    │        │
│       │                          ↓                                    │        │
│       │  ┌─────────────────────────────────────────────────────┐    │        │
│       │  │                   Planner Layer                      │    │        │
│       │  │         Logical Plan → Physical Plan                 │    │        │
│       │  └─────────────────────────────────────────────────────┘    │        │
│       │                          ↓                                    │        │
│       │  ┌─────────────────────────────────────────────────────┐    │        │
│       │  │                   Executor Layer                     │    │        │
│       │  │         Volcano Model → Operators                    │    │        │
│       │  └─────────────────────────────────────────────────────┘    │        │
│       │                          ↓                                    │        │
│       │  ┌─────────────────────────────────────────────────────┐    │        │
│       │  │                   Storage Layer                      │    │        │
│       │  │         Page → BufferPool → B+Tree → WAL             │    │        │
│       │  └─────────────────────────────────────────────────────┘    │        │
│       └─────────────────────────────────────────────────────────────┘        │
│                                                                              │
│   3.3 部署图                                                                 │
│       • 节点（Node）                                                         │
│       • 组件部署                                                             │
│       • 网络拓扑                                                             │
│       • SQLRustGo部署方案                                                    │
│                                                                              │
│   Part 4: 快速原型法（25分钟）                                                │
│   ─────────────────────────────                                              │
│   4.1 快速原型法的概念                                                       │
│       • 什么是原型                                                           │
│       • 原型的类型                                                           │
│         - 抛弃型原型                                                         │
│         - 演化型原型                                                         │
│       • 原型法的优缺点                                                       │
│                                                                              │
│   4.2 原型法开发流程                                                         │
│       • 需求分析 → 快速设计 → 原型构建 → 用户评估 → 迭代改进                 │
│       • 每个阶段的产物                                                       │
│                                                                              │
│   4.3 SQLRustGo草稿版本分析                                                  │
│       • 项目实施计划                                                         │
│       • 核心类型系统                                                         │
│       • 词法/语法分析器原型                                                  │
│       • 存储引擎基础结构                                                     │
│       • 草稿版本作为抛弃型原型的意义                                         │
│                                                                              │
│   4.4 AI辅助快速原型开发                                                     │
│       • 使用AI快速生成原型代码                                               │
│       • 使用AI生成设计文档                                                   │
│       • 原型评估和迭代                                                       │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 核心知识点

1. **顺序图**
   - 对象、生命线、消息、激活
   - 同步/异步消息
   - SQL查询执行流程建模

2. **状态图**
   - 状态、转换、事件、动作
   - 事务状态建模

3. **架构设计**
   - 分层架构
   - SQLRustGo四层架构
   - 部署图

4. **快速原型法**
   - 原型类型：抛弃型 vs 演化型
   - 开发流程
   - AI辅助原型开发

### 课堂互动

- 练习：绘制SQL查询执行顺序图
- 练习：绘制事务状态图
- 讨论：原型法在AI时代有什么新意义？
- 实践：分析SQLRustGo草稿版本

### 课后作业

1. 完成SQLRustGo顺序图（至少2个场景）
2. 完成事务状态图
3. 绘制系统架构图
4. 编写快速原型设计文档

---

## 第五讲：架构设计原理与SQLRustGo架构（第5周）

### PPT结构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        第五讲：架构设计原理与SQLRustGo架构                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Part 1: 架构设计概述（25分钟）                                              │
│   ─────────────────────────────                                              │
│   1.1 What：什么是软件架构                                                   │
│       • 定义：软件系统的高层结构，包括组件、组件关系、组件与环境的关系          │
│       • 架构的层次                                                           │
│         - 业务架构：业务流程、业务规则                                          │
│         - 应用架构：功能模块、模块关系                                          │
│         - 数据架构：数据模型、数据流向                                          │
│         - 技术架构：技术选型、基础设施                                          │
│       • 架构的核心要素                                                       │
│         - 组件（Component）：功能单元                                          │
│         - 连接器（Connector）：组件间的通信机制                                 │
│         - 约束（Constraint）：架构的限制条件                                    │
│       • 架构设计原则                                                         │
│         - 高内聚低耦合                                                       │
│         - 关注点分离                                                         │
│         - 单一职责                                                           │
│         - 开闭原则                                                           │
│                                                                              │
│   1.2 Why：为什么需要架构设计                                               │
│       • 复杂性管理                                                           │
│         - 大型系统包含数百万行代码                                             │
│         - 没有良好架构，系统无法理解和维护                                     │
│         - 架构提供系统的"地图"和"导航"                                         │
│       • 质量保证                                                             │
│         - 架构决定系统的质量属性（性能、可扩展性、可靠性）                        │
│         - 良好架构降低Bug数量                                                 │
│         - 提高代码可读性和可维护性                                             │
│       • 团队协作                                                             │
│         - 清晰的架构让多人协作成为可能                                         │
│         - 降低沟通成本                                                       │
│         - 减少代码冲突                                                       │
│       • 风险控制                                                             │
│         - 架构设计提前识别风险                                                 │
│         - 降低后期重构成本                                                     │
│         - 提高系统稳定性                                                       │
│       • 成本控制                                                             │
│         - 架构设计成本 << 重构成本                                            │
│         - 良好架构降低长期维护成本                                             │
│       • 业界案例                                                             │
│         - Google：微服务架构支撑全球搜索                                       │
│         - Netflix：云原生架构支撑流媒体服务                                     │
│         - 微信：分布式架构支撑亿级用户                                         │
│                                                                              │
│   1.3 How：如何进行架构设计                                                 │
│       • 架构设计流程                                                         │
│         1. 需求分析：理解业务需求和技术约束                                      │
│         2. 架构风格选择：选择合适的架构模式                                     │
│         3. 组件设计：识别核心组件和接口                                          │
│         4. 架构评估：评估架构方案的优劣                                         │
│         5. 迭代优化：根据反馈持续优化                                          │
│       • 架构风格选择                                                         │
│         - 分层架构（Layered Architecture）                                     │
│           • 适用：大多数企业应用                                               │
│           • 优点：结构清晰、易于理解                                           │
│           • 缺点：性能开销、灵活性差                                           │
│         - 微服务架构（Microservices Architecture）                              │
│           • 适用：大型分布式系统                                               │
│           • 优点：可扩展、独立部署                                             │
│           • 缺点：复杂度高、运维成本大                                         │
│         - 事件驱动架构（Event-Driven Architecture）                             │
│           • 适用：实时系统、异步处理                                            │
│           • 优点：解耦、响应快                                                 │
│           • 缺点：调试困难、一致性难保证                                         │
│         - 管道过滤器架构（Pipe-Filter Architecture）                           │
│           • 适用：数据处理系统                                                 │
│           • 优点：可组合、可重用                                               │
│           • 缺点：性能开销、错误处理复杂                                         │
│       • 架构评估方法                                                         │
│         - ATAM（Architecture Tradeoff Analysis Method）                        │
│         - SAAM（Software Architecture Analysis Method）                         │
│         - 架构权衡：性能 vs 可扩展性 vs 复杂度                                   │
│       • AI辅助架构设计                                                       │
│         - 使用AI生成架构方案                                                   │
│         - 使用AI评估架构优劣                                                   │
│         - 使用AI生成架构图                                                     │
│         - 提示词设计：                                                         │
│           """                                                                  │
│           设计一个数据库系统的架构，要求：                                      │
│           1. 支持SQL查询                                                       │
│           2. 支持数据持久化                                                     │
│           3. 支持事务处理                                                     │
│           4. 支持并发访问                                                     │
│           5. 使用Rust实现                                                     │
│           请提供架构方案、组件划分、接口设计。                                  │
│           """                                                                  │
│                                                                              │
│   Part 2: SQLRustGo四层架构设计（30分钟）                                      │
│   ─────────────────────────────────                                          │
│   2.1 What：SQLRustGo的架构设计                                             │
│       • 整体架构图                                                           │
│         ┌─────────────────────────────────────────────────────────────┐        │
│         │                    SQLRustGo 架构                            │        │
│         ├─────────────────────────────────────────────────────────────┤        │
│         │  ┌─────────────────────────────────────────────────────┐    │        │
│         │  │                    Parser Layer                      │    │        │
│         │  │         Lexer → Parser → AST                         │    │        │
│         │  │         功能：SQL解析、语法检查                        │    │        │
│         │  └─────────────────────────────────────────────────────┘    │        │
│         │                          ↓                                    │        │
│         │  ┌─────────────────────────────────────────────────────┐    │        │
│         │  │                   Planner Layer                      │    │        │
│         │  │         Logical Plan → Physical Plan                 │    │        │
│         │  │         功能：查询优化、执行计划生成                   │    │        │
│         │  └─────────────────────────────────────────────────────┘    │        │
│         │                          ↓                                    │        │
│         │  ┌─────────────────────────────────────────────────────┐    │        │
│         │  │                   Executor Layer                     │    │        │
│         │  │         Volcano Model → Operators                    │    │        │
│         │  │         功能：查询执行、结果返回                      │    │        │
│         │  └─────────────────────────────────────────────────────┘    │        │
│         │                          ↓                                    │        │
│         │  ┌─────────────────────────────────────────────────────┐    │        │
│         │  │                   Storage Layer                      │    │        │
│         │  │         Page → BufferPool → B+Tree → WAL             │    │        │
│         │  │         功能：数据存储、索引管理、事务支持            │    │        │
│         │  └─────────────────────────────────────────────────────┘    │        │
│         └─────────────────────────────────────────────────────────────┘        │
│                                                                              │
│   2.2 Why：为什么选择四层架构                                               │
│       • 分层架构的优势                                                       │
│         - 关注点分离：每层专注自己的职责                                        │
│         - 易于理解：清晰的层次结构                                             │
│         - 易于测试：每层可独立测试                                             │
│         - 易于扩展：可以替换某一层的实现                                        │
│       • 数据库系统的特性                                                       │
│         - 解析层：处理SQL语法，与存储无关                                       │
│         - 规划层：优化查询，与具体存储无关                                       │
│         - 执行层：执行查询，依赖存储层                                         │
│         - 存储层：管理数据，独立于上层                                         │
│       • 教学价值                                                             │
│         - 每层对应数据库系统的核心概念                                          │
│         - 学生可以逐层学习和实现                                               │
│         - 适合AI辅助开发（每层相对独立）                                        │
│       • 可扩展性                                                             │
│         - 可以添加新的SQL语法（修改Parser层）                                   │
│         - 可以添加新的优化规则（修改Planner层）                                 │
│         - 可以添加新的执行算子（修改Executor层）                                │
│         - 可以添加新的存储引擎（修改Storage层）                                 │
│                                                                              │
│   2.3 How：四层架构的详细设计                                               │
│       • Parser Layer（解析层）                                                │
│         - 组件：                                                             │
│           • Lexer：词法分析器，将SQL字符串转换为Token流                          │
│           • Parser：语法分析器，将Token流转换为AST                              │
│           • AST：抽象语法树，表示SQL语句的结构                                   │
│         - 输入：SQL字符串                                                     │
│         - 输出：AST（Statement枚举）                                           │
│         - 关键技术：                                                         │
│           • 正则表达式（词法分析）                                             │
│           • 递归下降解析（语法分析）                                             │
│           • 错误处理和恢复                                                     │
│       • Planner Layer（规划层）                                               │
│         - 组件：                                                             │
│           • Logical Planner：逻辑规划器，生成逻辑执行计划                          │
│           • Physical Planner：物理规划器，生成物理执行计划                        │
│           • Optimizer：查询优化器，优化执行计划                                  │
│         - 输入：AST（来自Parser层）                                           │
│         - 输出：Physical Plan（执行计划）                                       │
│         - 关键技术：                                                         │
│           • 基于规则的优化（Rule-based Optimization）                           │
│           • 基于成本的优化（Cost-based Optimization）                           │
│           • 索引选择                                                         │
│       • Executor Layer（执行层）                                               │
│         - 组件：                                                             │
│           • ExecutionEngine：执行引擎，协调算子执行                              │
│           • Operators：执行算子（Scan, Filter, Project, Join等）                │
│           • Volcano Model：火山模型，算子迭代执行                                │
│         - 输入：Physical Plan（来自Planner层）                                  │
│         - 输出：Query Result（查询结果）                                        │
│         - 关键技术：                                                         │
│           • 迭代器模式（Iterator Pattern）                                      │
│           • 流水线执行（Pipeline Execution）                                    │
│           • 向量化执行（Vectorized Execution）                                   │
│       • Storage Layer（存储层）                                               │
│         - 组件：                                                             │
│           • Page：存储页，数据存储的基本单位                                     │
│           • BufferPool：缓冲池，管理内存中的页                                   │
│           • BPlusTree：B+树索引，加速数据查询                                   │
│           • WAL：Write-Ahead Log，预写日志，保证事务持久性                        │
│           • Transaction Manager：事务管理器，管理ACID事务                        │
│         - 输入：读写请求（来自Executor层）                                      │
│         - 输出：数据或操作结果                                                 │
│         - 关键技术：                                                         │
│           • 页式存储（Page-based Storage）                                     │
│           • 缓冲区管理（Buffer Management）                                    │
│           • B+树索引（B+ Tree Indexing）                                       │
│           • WAL日志（Write-Ahead Logging）                                      │
│           • 并发控制（Concurrency Control）                                     │
│                                                                              │
│   Part 3: 架构图绘制实践（20分钟）                                              │
│   ─────────────────────────────                                              │
│   3.1 使用PlantUML绘制架构图                                                 │
│       • PlantUML组件图语法                                                   │
│       • SQLRustGo架构图代码                                                   │
│       • 使用AI生成架构图代码                                                   │
│                                                                              │
│   3.2 架构设计评审                                                           │
│       • 评审要点：                                                           │
│         - 架构是否清晰？                                                     │
│         - 职责是否分离？                                                     │
│         - 是否易于扩展？                                                     │
│         - 是否易于测试？                                                     │
│       • 评审方法：                                                           │
│         - 同行评审（Peer Review）                                             │
│         - 架构评估会议（Architecture Review Meeting）                          │
│         - 架构权衡分析（Tradeoff Analysis）                                    │
│                                                                              │
│   Part 4: AI辅助架构设计实践（10分钟）                                         │
│   ─────────────────────────────────                                          │
│   4.1 使用AI生成架构方案                                                     │
│       • 提示词设计                                                           │
│       • 方案评估                                                             │
│       • 迭代优化                                                             │
│                                                                              │
│   4.2 使用AI生成架构图                                                       │
│       • PlantUML代码生成                                                     │
│       • 图形渲染                                                             │
│       • 文档输出                                                             │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 核心知识点

1. **架构设计**
   - What：软件架构的定义、层次、核心要素
   - Why：复杂性管理、质量保证、团队协作、风险控制、成本控制
   - How：架构设计流程、架构风格选择、架构评估方法、AI辅助设计

2. **SQLRustGo四层架构**
   - Parser Layer：SQL解析
   - Planner Layer：查询优化
   - Executor Layer：查询执行
   - Storage Layer：数据存储

3. **架构设计实践**
   - PlantUML绘制架构图
   - 架构设计评审
   - AI辅助架构设计

### 课堂互动

- 讨论：架构设计在AI时代还有价值吗？
- 练习：使用AI生成SQLRustGo架构图
- 评审：分析现有架构的优缺点

### 课后作业

1. 完成SQLRustGo架构图（使用PlantUML）
2. 编写架构设计文档
3. 使用AI生成一个架构方案并评估

---

## 第六讲：功能模块划分与接口设计（第6周）

### PPT结构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        第六讲：功能模块划分与接口设计                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Part 1: 功能模块划分（25分钟）                                              │
│   ─────────────────────────────                                              │
│   1.1 What：什么是功能模块                                                   │
│       • 定义：功能模块是具有独立功能的软件单元，通过接口对外提供服务              │
│       • 模块的特性                                                           │
│         - 独立性：模块可以独立开发、测试、部署                                  │
│         - 可重用性：模块可以在不同场景中重用                                    │
│         - 可替换性：模块可以被其他实现替换                                      │
│         - 封装性：模块隐藏内部实现细节                                          │
│       • 模块的粒度                                                           │
│         - 粗粒度模块：功能完整、接口复杂（如存储引擎）                            │
│         - 细粒度模块：功能单一、接口简单（如词法分析器）                          │
│       • 模块划分原则                                                         │
│         - 高内聚：模块内部元素紧密相关                                          │
│         - 低耦合：模块之间依赖最小化                                          │
│         - 单一职责：一个模块只负责一个功能                                      │
│         - 接口稳定：模块接口应该稳定，内部实现可以变化                            │
│                                                                              │
│   1.2 Why：为什么需要功能模块划分                                           │
│       • 复杂性管理                                                           │
│         - 大型系统包含数百个功能                                               │
│         - 模块化将复杂问题分解为简单问题                                        │
│         - 降低认知负荷                                                       │
│       • 团队协作                                                             │
│         - 不同团队可以负责不同模块                                             │
│         - 减少代码冲突                                                       │
│         - 提高并行开发效率                                                   │
│       • 可维护性                                                             │
│         - 模块化使代码更易理解和修改                                           │
│         - Bug定位更精确                                                     │
│         - 重构范围更可控                                                     │
│       • 可测试性                                                             │
│         - 模块可以独立测试                                                   │
│         - 测试覆盖率更高                                                     │
│         - Mock和Stub更容易实现                                                │
│       • 可扩展性                                                             │
│         - 新功能可以作为新模块添加                                            │
│         - 现有模块可以独立升级                                                │
│         - 支持插件化架构                                                     │
│       • 业界案例                                                             │
│         - Linux内核：模块化设计支持动态加载驱动                                 │
│         - Chrome浏览器：多进程架构提高稳定性                                    │
│         - VS Code：插件架构支持扩展                                           │
│                                                                              │
│   1.3 How：如何进行功能模块划分                                             │
│       • 模块划分方法                                                         │
│         - 按功能划分（Functional Decomposition）                               │
│           • 依据：业务功能                                                   │
│           • 示例：用户管理、订单管理、支付模块                                 │
│           • 优点：符合业务逻辑、易于理解                                       │
│           • 缺点：可能导致功能耦合                                           │
│         - 按层次划分（Layered Decomposition）                                 │
│           • 依据：系统层次                                                   │
│           • 示例：表示层、业务层、数据层                                       │
│           • 优点：结构清晰、易于测试                                           │
│           • 缺点：跨层次调用复杂                                             │
│         - 按数据划分（Data-Oriented Decomposition）                            │
│           • 依据：数据实体                                                   │
│           • 示例：用户模块、商品模块、订单模块                                   │
│           • 优点：数据一致性好                                                 │
│           • 缺点：可能产生数据冗余                                             │
│       • 模块划分流程                                                         │
│         1. 需求分析：识别系统功能                                              │
│         2. 功能聚类：将相关功能归类                                          │
│         3. 模块识别：识别候选模块                                            │
│         4. 接口设计：设计模块接口                                            │
│         5. 依赖分析：分析模块依赖关系                                          │
│         6. 迭代优化：根据反馈优化模块划分                                      │
│       • 模块划分评估                                                         │
│         - 内聚度评估：模块内部元素的相关程度                                    │
│         - 耦合度评估：模块之间的依赖程度                                        │
│         - 复杂度评估：模块的复杂程度                                          │
│         - 可测试性评估：模块是否易于测试                                       │
│       • AI辅助模块划分                                                       │
│         - 使用AI分析需求文档，识别功能模块                                      │
│         - 使用AI评估模块划分方案                                              │
│         - 使用AI生成模块依赖图                                                │
│         - 提示词设计：                                                         │
│           """                                                                  │
│           分析以下数据库系统的需求，进行功能模块划分：                          │
│           [需求文档]                                                          │
│           要求：                                                               │
│           1. 识别核心功能模块                                                │
│           2. 说明每个模块的职责                                                │
│           3. 分析模块之间的依赖关系                                            │
│           4. 评估模块划分的合理性（高内聚、低耦合）                              │
│           """                                                                  │
│                                                                              │
│   Part 2: SQLRustGo功能模块划分（30分钟）                                     │
│   ─────────────────────────────────                                          │
│   2.1 模块划分方案                                                         │
│       ┌─────────────────────────────────────────────────────────────┐        │
│       │                    SQLRustGo 模块划分                        │        │
│       ├─────────────────────────────────────────────────────────────┤        │
│       │  ┌─────────────────────────────────────────────────────┐    │        │
│       │  │              Parser 模块                              │    │        │
│       │  │  • Lexer：词法分析器                                   │    │        │
│       │  │  • Parser：语法分析器                                  │    │        │
│       │  │  • AST：抽象语法树                                    │    │        │
│       │  │  职责：将SQL字符串转换为AST                            │    │        │
│       │  └─────────────────────────────────────────────────────┘    │        │
│       │                          ↓                                    │        │
│       │  ┌─────────────────────────────────────────────────────┐    │        │
│       │  │              Planner 模块                             │    │        │
│       │  │  • LogicalPlanner：逻辑规划器                         │    │        │
│       │  │  • PhysicalPlanner：物理规划器                        │    │        │
│       │  │  • Optimizer：查询优化器                               │    │        │
│       │  │  职责：生成优化的执行计划                              │    │        │
│       │  └─────────────────────────────────────────────────────┘    │        │
│       │                          ↓                                    │        │
│       │  ┌─────────────────────────────────────────────────────┐    │        │
│       │  │             Executor 模块                              │    │        │
│       │  │  • ExecutionEngine：执行引擎                           │    │        │
│       │  │  • Operators：执行算子                                │    │        │
│       │  │  职责：执行查询并返回结果                              │    │        │
│       │  └─────────────────────────────────────────────────────┘    │        │
│       │                          ↓                                    │        │
│       │  ┌─────────────────────────────────────────────────────┐    │        │
│       │  │             Storage 模块                              │    │        │
│       │  │  • PageManager：页管理器                              │    │        │
│       │  │  • BufferPool：缓冲池                                 │    │        │
│       │  │  • BPlusTree：B+树索引                               │    │        │
│       │  │  • WAL：预写日志                                     │    │        │
│       │  │  • TransactionManager：事务管理器                     │    │        │
│       │  │  职责：数据存储、索引、事务                            │    │        │
│       │  └─────────────────────────────────────────────────────┘    │        │
│       │                          ↓                                    │        │
│       │  ┌─────────────────────────────────────────────────────┐    │        │
│       │  │             Common 模块                               │    │        │
│       │  │  • Value：数据值类型                                  │    │        │
│       │  │  • DataType：数据类型枚举                              │    │        │
│       │  │  • SqlError：错误类型                                │    │        │
│       │  │  职责：公共数据类型和工具                              │    │        │
│       │  └─────────────────────────────────────────────────────┘    │        │
│       └─────────────────────────────────────────────────────────────┘        │
│                                                                              │
│   2.2 模块依赖关系                                                         │
│       • Parser → Common：依赖公共数据类型                                     │
│       • Planner → Parser, Common：依赖AST和公共类型                            │
│       • Executor → Planner, Storage, Common：依赖执行计划和存储层             │
│       • Storage → Common：依赖公共数据类型                                    │
│       • 所有模块 → Common：依赖公共类型                                        │
│       • 依赖方向：上层依赖下层，下层不依赖上层                                  │
│                                                                              │
│   2.3 模块接口设计                                                         │
│       • Parser模块接口                                                       │
│         ```rust                                                              │
│         pub trait Lexer {                                                     │
│             fn next_token(&mut self) -> Result<Token, SqlError>;             │
│         }                                                                     │
│                                                                              │
│         pub trait Parser {                                                     │
│             fn parse(&mut self, sql: &str) -> Result<Statement, SqlError>;   │
│         }                                                                     │
│         ```                                                                  │
│       • Planner模块接口                                                      │
│         ```rust                                                              │
│         pub trait LogicalPlanner {                                            │
│             fn plan(&self, stmt: &Statement) -> Result<LogicalPlan, SqlError>;│
│         }                                                                     │
│                                                                              │
│         pub trait PhysicalPlanner {                                           │
│             fn plan(&self, logical: &LogicalPlan) -> Result<PhysicalPlan, SqlError>;│
│         }                                                                     │
│         ```                                                                  │
│       • Executor模块接口                                                     │
│         ```rust                                                              │
│         pub trait ExecutionEngine {                                           │
│             fn execute(&mut self, plan: &PhysicalPlan) -> Result<ExecutionResult, SqlError>;│
│         }                                                                     │
│         ```                                                                  │
│       • Storage模块接口                                                      │
│         ```rust                                                              │
│         pub trait PageManager {                                               │
│             fn read_page(&self, page_id: PageId) -> Result<Page, SqlError>;   │
│             fn write_page(&mut self, page: &Page) -> Result<(), SqlError>;   │
│         }                                                                     │
│                                                                              │
│         pub trait BufferPool {                                                │
│             fn get_page(&mut self, page_id: PageId) -> Result<&Page, SqlError>;│
│             fn put_page(&mut self, page: Page) -> Result<(), SqlError>;      │
│         }                                                                     │
│         ```                                                                  │
│                                                                              │
│   Part 3: 接口设计原则与实践（20分钟）                                        │
│   ─────────────────────────────────                                          │
│   3.1 What：什么是接口设计                                                   │
│       • 接口的定义：模块之间交互的契约                                          │
│       • 接口的组成：                                                         │
│         - 方法签名：方法名、参数、返回值                                        │
│         - 行为契约：前置条件、后置条件、不变式                                   │
│         - 错误处理：错误类型、错误传播                                         │
│       • 接口的类型：                                                         │
│         - 同步接口：调用者等待结果                                             │
│         - 异步接口：调用者不等待结果                                           │
│         - 流式接口：返回数据流                                                 │
│                                                                              │
│   3.2 Why：接口设计的重要性                                                 │
│       • 解耦：接口降低模块之间的耦合度                                          │
│       • 可测试性：接口使Mock和Stub更容易实现                                    │
│       • 可替换性：接口允许替换实现而不影响调用者                                 │
│       • 可扩展性：接口支持新功能的添加                                         │
│       • 文档作用：接口本身就是文档                                             │
│                                                                              │
│   3.3 How：接口设计原则                                                     │
│       • 接口隔离原则（ISP）                                                  │
│         - 接口要小而专一                                                     │
│         - 客户端不应该依赖它不需要的接口                                        │
│       • 最小知识原则（Law of Demeter）                                        │
│         - 模块只与直接的朋友通信                                              │
│         - 减少模块之间的依赖                                                 │
│       • 契约式设计（Design by Contract）                                      │
│         - 明确前置条件、后置条件、不变式                                        │
│         - 使用类型系统保证契约                                                │
│       • 错误处理原则                                                         │
│         - 使用Result类型表示可能失败的操作                                      │
│         - 错误类型应该包含足够的信息                                            │
│         - 错误应该向上传播到合适的处理层                                        │
│       • Rust接口设计实践                                                     │
│         - 使用trait定义接口                                                   │
│         - 使用泛型支持多种实现                                                │
│         - 使用生命周期标注引用关系                                             │
│         - 使用Send和Sync标记线程安全                                           │
│                                                                              │
│   Part 4: AI辅助接口设计实践（10分钟）                                         │
│   ─────────────────────────────────                                          │
│   4.1 使用AI设计接口                                                       │
│       • 提示词设计：                                                         │
│         """                                                                  │
│         设计数据库缓冲池的接口，要求：                                        │
│         1. 支持获取页面：get_page(page_id)                                   │
│         2. 支持插入页面：put_page(page)                                      │
│         3. 支持LRU置换算法                                                   │
│         4. 支持脏页标记                                                      │
│         5. 使用Rust trait定义                                               │
│         6. 考虑线程安全                                                      │
│         """                                                                  │
│       • 评估接口设计                                                         │
│       • 迭代优化                                                             │
│                                                                              │
│   4.2 接口评审                                                             │
│       • 评审要点：                                                           │
│         - 接口是否简洁？                                                     │
│         - 接口是否完整？                                                     │
│         - 接口是否稳定？                                                     │
│         - 错误处理是否合理？                                                 │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 核心知识点

1. **功能模块划分**
   - What：功能模块的定义、特性、粒度、划分原则
   - Why：复杂性管理、团队协作、可维护性、可测试性、可扩展性
   - How：划分方法、划分流程、评估方法、AI辅助划分

2. **SQLRustGo模块划分**
   - Parser模块、Planner模块、Executor模块、Storage模块、Common模块
   - 模块依赖关系
   - 模块接口设计

3. **接口设计**
   - 接口设计原则：ISP、最小知识原则、契约式设计、错误处理原则
   - Rust接口设计实践
   - AI辅助接口设计

### 课堂互动

- 练习：使用AI分析需求文档，识别功能模块
- 练习：设计一个模块的接口
- 评审：评估接口设计的优缺点

### 课后作业

1. 完成SQLRustGo模块划分文档
2. 设计所有模块的接口
3. 绘制模块依赖图

---

## 第七讲：AI辅助核心模块实现（第7周）

### PPT结构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        第七讲：AI辅助核心模块实现                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Part 1: AI辅助开发概述（20分钟）                                            │
│   ─────────────────────────────                                              │
│   1.1 What：AI辅助开发是什么                                                 │
│       • 定义：使用AI工具辅助软件开发的各个环节                                │
│       • AI辅助开发的阶段                                                     │
│         - 需求分析：AI分析需求文档，识别功能点                                │
│         - 设计阶段：AI生成设计方案、架构图、接口设计                           │
│         - 编码阶段：AI生成代码、补全代码、重构代码                             │
│         - 测试阶段：AI生成测试用例、分析覆盖率                                │
│         - 文档阶段：AI生成文档、翻译文档                                       │
│       • AI辅助开发工具                                                       │
│         - AI-IDE：Cursor、TRAE IDE、Claude Code                               │
│         - AI编程助手：GitHub Copilot、TabNine                                 │
│         - AI聊天机器人：ChatGPT、Claude、Gemini                                │
│         - AI代码审查：SonarQube AI、DeepCode                                  │
│                                                                              │
│   1.2 Why：为什么使用AI辅助开发                                             │
│       • 提高效率                                                             │
│         - AI可以快速生成样板代码                                              │
│         - AI可以自动补全代码                                                 │
│         - AI可以批量生成测试用例                                              │
│         - 开发效率提升2-5倍                                                  │
│       • 降低门槛                                                             │
│         - 新手可以借助AI快速上手                                              │
│         - AI可以解释复杂代码                                                 │
│         - AI可以提供最佳实践建议                                              │
│       • 提高质量                                                             │
│         - AI可以生成规范的代码                                                │
│         - AI可以自动发现Bug                                                  │
│         - AI可以建议重构方案                                                 │
│       • 加速学习                                                             │
│         - AI可以解释概念                                                     │
│         - AI可以提供示例                                                     │
│         - AI可以回答问题                                                     │
│       • 业界案例                                                             │
│         - GitHub：Copilot帮助开发者提高55%的编码速度                          │
│         - Microsoft：AI辅助开发减少30%的Bug                                   │
│         - Google：AI代码审查提高代码质量                                       │
│                                                                              │
│   1.3 How：如何有效使用AI辅助开发                                           │
│       • AI辅助开发流程                                                       │
│         1. 明确需求：清楚描述要实现的功能                                      │
│         2. 设计提示词：编写清晰、完整的提示词                                   │
│         3. 生成代码：使用AI生成初始代码                                        │
│         4. 代码审查：人工审查AI生成的代码                                      │
│         5. 测试验证：编写测试用例，验证功能                                    │
│         6. 迭代优化：根据反馈优化代码                                          │
│       • 提示词工程                                                           │
│         - 清晰性：明确任务目标，避免歧义                                        │
│         - 完整性：提供必要上下文，指定约束条件                                  │
│         - 结构性：使用结构化格式，分步骤描述                                    │
│         - 可迭代性：便于反馈修正，支持渐进优化                                  │
│       • 代码审查要点                                                         │
│         - 正确性：代码是否实现了预期功能                                        │
│         - 安全性：是否存在安全漏洞                                            │
│         - 性能：是否存在性能问题                                              │
│         - 可读性：代码是否易于理解                                            │
│         - 可维护性：代码是否易于修改                                            │
│       • AI辅助开发的局限性                                                   │
│         - 上下文窗口限制：AI无法理解整个大型项目                                │
│         - 创造性限制：AI难以创造全新的解决方案                                  │
│         - 领域知识限制：AI缺乏特定领域的专业知识                                │
│         - 责任问题：AI生成的代码需要人工负责                                   │
│                                                                              │
│   Part 2: AI辅助实现词法分析器（30分钟）                                       │
│   ─────────────────────────────────                                          │
│   2.1 词法分析原理                                                         │
│       • 词法分析的作用：将SQL字符串转换为Token流                                │
│       • Token类型：关键字、标识符、字面量、运算符、分隔符                        │
│       • 正则表达式：描述Token的模式                                          │
│       • 有限状态机（FSM）：实现词法分析器                                      │
│                                                                              │
│   2.2 What：使用AI生成Token定义                                            │
│       • 提示词设计：                                                         │
│         """                                                                  │
│         设计一个SQL词法分析器的Token枚举，支持：                              │
│         - SQL关键字：SELECT, FROM, WHERE, INSERT, UPDATE, DELETE, CREATE, DROP, TABLE│
│         - 标识符：表名、列名                                                 │
│         - 字面量：字符串、整数、浮点数、布尔值                                  │
│         - 运算符：=, <>, <, >, <=, >=, +, -, *, /, AND, OR, NOT             │
│         - 分隔符：, ( ) ; .                                                  │
│         使用Rust枚举实现，包含Debug和Clone trait。                          │
│         """                                                                  │
│       • AI输出：Token枚举定义                                                │
│       • 人工审查：检查Token类型是否完整、命名是否规范                           │
│                                                                              │
│   2.3 How：使用AI生成词法分析器                                             │
│       • 提示词设计：                                                         │
│         """                                                                  │
│         基于以下Token定义，实现一个SQL词法分析器：                            │
│         [Token定义代码]                                                      │
│         要求：                                                               │
│         1. 实现Lexer结构体，包含input和position字段                          │
│         2. 实现next_token()方法，返回下一个Token                             │
│         3. 支持跳过空白字符（空格、制表符、换行）                              │
│         4. 支持识别关键字和标识符（区分大小写）                                │
│         5. 支持识别整数和浮点数字面量                                         │
│         6. 支持识别字符串字面量（单引号和双引号）                              │
│         7. 支持识别运算符和分隔符                                             │
│         8. 使用Rust实现，考虑错误处理                                        │
│         """                                                                  │
│       • AI输出：Lexer实现代码                                                │
│       • 代码审查：                                                           │
│         - 检查逻辑是否正确                                                   │
│         - 检查错误处理是否完善                                                │
│         - 检查边界条件是否处理                                                │
│       • 测试验证：编写测试用例，验证功能                                       │
│                                                                              │
│   Part 3: AI辅助实现语法分析器（30分钟）                                       │
│   ─────────────────────────────────                                          │
│   3.1 语法分析原理                                                         │
│       • 语法分析的作用：将Token流转换为AST                                      │
│       • 上下文无关文法：描述SQL语法                                           │
│       • 抽象语法树（AST）：表示SQL语句的结构                                   │
│       • 递归下降解析：实现语法分析器                                          │
│                                                                              │
│   3.2 What：使用AI生成AST定义                                              │
│       • 提示词设计：                                                         │
│         """                                                                  │
│         设计SQL语句的AST节点，支持：                                         │
│         - SELECT语句：columns（列列表）, from_table（表名）, where_clause（WHERE条件）, limit（限制数量）│
│         - INSERT语句：table（表名）, columns（列列表）, values（值列表）       │
│         - UPDATE语句：table（表名）, set_clauses（SET子句）, where_clause（WHERE条件）│
│         - DELETE语句：table（表名）, where_clause（WHERE条件）                │
│         - CREATE TABLE语句：table_name（表名）, columns（列定义列表）          │
│         - DROP TABLE语句：table_name（表名）                                  │
│         使用Rust结构体和枚举实现，包含Debug和Clone trait。                   │
│         """                                                                  │
│       • AI输出：AST定义代码                                                 │
│       • 人工审查：检查AST结构是否合理、字段是否完整                            │
│                                                                              │
│   3.3 How：使用AI生成语法分析器                                             │
│       • 提示词设计：                                                         │
│         """                                                                  │
│         基于以下Token和AST定义，实现一个SQL语法分析器：                       │
│         [Token定义代码]                                                      │
│         [AST定义代码]                                                        │
│         要求：                                                               │
│         1. 实现Parser结构体，包含lexer字段                                   │
│         2. 实现parse()方法，解析SQL字符串并返回AST                            │
│         3. 支持解析SELECT语句                                                │
│         4. 支持解析INSERT语句                                                │
│         5. 支持解析UPDATE语句                                                │
│         6. 支持解析DELETE语句                                                │
│         7. 支持解析CREATE TABLE语句                                          │
│         8. 支持解析DROP TABLE语句                                            │
│         9. 使用Rust实现，考虑错误处理                                        │
│         10. 提供清晰的错误信息                                                │
│         """                                                                  │
│       • AI输出：Parser实现代码                                               │
│       • 代码审查：                                                           │
│         - 检查解析逻辑是否正确                                               │
│         - 检查错误处理是否完善                                                │
│         - 检查是否支持所有SQL语句                                             │
│       • 测试验证：编写测试用例，验证功能                                       │
│                                                                              │
│   Part 4: AI辅助实现存储引擎（30分钟）                                         │
│   ─────────────────────────────────                                          │
│   4.1 存储引擎原理                                                         │
│       • 页式存储：数据以页为单位存储                                          │
│       • 缓冲池：管理内存中的页                                               │
│       • B+树索引：加速数据查询                                               │
│       • WAL日志：保证事务持久性                                              │
│                                                                              │
│   4.2 What：使用AI设计页结构                                               │
│       • 提示词设计：                                                         │
│         """                                                                  │
│         设计数据库存储页结构，要求：                                         │
│         1. 页大小：8KB                                                      │
│         2. 页头：页ID（4字节）、页类型（1字节）、空闲空间指针（2字节）         │
│         3. 数据区：存储实际数据                                               │
│         4. 方法：read(offset, len)读取数据、write(offset, data)写入数据       │
│         5. 使用Rust实现，考虑内存安全                                        │
│         6. 支持序列化和反序列化                                              │
│         """                                                                  │
│       • AI输出：Page结构体代码                                              │
│       • 人工审查：检查页结构是否合理、方法是否完整                              │
│                                                                              │
│   4.3 How：使用AI实现缓冲池                                                 │
│       • 提示词设计：                                                         │
│         """                                                                  │
│         实现数据库缓冲池管理器，要求：                                       │
│         1. 容量可配置（默认100页）                                            │
│         2. 使用LRU置换算法                                                   │
│         3. 支持get(page_id)获取页面                                          │
│         4. 支持put(page_id, page)插入页面                                     │
│         5. 支持脏页标记                                                      │
│         6. 支持flush()刷盘所有脏页                                           │
│         7. 使用Rust实现，考虑线程安全                                        │
│         8. 使用HashMap和LinkedList实现LRU                                    │
│         """                                                                  │
│       • AI输出：BufferPool实现代码                                           │
│       • 代码审查：                                                           │
│         - 检查LRU算法是否正确                                                │
│         - 检查并发安全是否保证                                                │
│         - 检查脏页管理是否完善                                                │
│       • 测试验证：编写测试用例，验证功能                                       │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 核心知识点

1. **AI辅助开发**
   - What：AI辅助开发的定义、阶段、工具
   - Why：提高效率、降低门槛、提高质量、加速学习
   - How：开发流程、提示词工程、代码审查、局限性

2. **AI辅助实现词法分析器**
   - Token定义
   - Lexer实现
   - 测试验证

3. **AI辅助实现语法分析器**
   - AST定义
   - Parser实现
   - 测试验证

4. **AI辅助实现存储引擎**
   - Page结构
   - BufferPool实现
   - 测试验证

### 课堂互动

- 练习：使用AI生成Token定义
- 练习：使用AI生成Lexer实现
- 练习：使用AI生成AST定义
- 练习：使用AI生成Parser实现
- 讨论：AI生成的代码需要哪些审查？

### 课后作业

1. 完成词法分析器实现
2. 完成语法分析器实现
3. 完成页结构和缓冲池实现
4. 编写测试用例

---

## 第八讲：测试驱动开发与Alpha版本（第8周）

### PPT结构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        第八讲：测试驱动开发与Alpha版本                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Part 1: 测试驱动开发（TDD）（25分钟）                                       │
│   ─────────────────────────────                                              │
│   1.1 TDD的核心思想                                                          │
│       • 测试先行                                                             │
│       • 快速反馈                                                             │
│       • 持续重构                                                             │
│                                                                              │
│   1.2 Red-Green-Refactor循环                                                 │
│       • Red：编写失败的测试                                                  │
│       • Green：编写最少代码使测试通过                                        │
│       • Refactor：重构代码                                                   │
│       • 循环迭代                                                             │
│                                                                              │
│   1.3 测试先行的好处                                                         │
│       • 更好的设计                                                           │
│       • 更高的测试覆盖率                                                     │
│       • 更少的Bug                                                            │
│       • 文档作用                                                             │
│                                                                              │
│   1.4 TDD实践技巧                                                            │
│       • 从简单测试开始                                                       │
│       • 保持测试独立                                                         │
│       • 测试命名规范                                                         │
│       • 使用AI辅助TDD                                                        │
│                                                                              │
│   Part 2: AI辅助测试生成（25分钟）                                            │
│   ─────────────────────────────                                              │
│   2.1 使用AI生成测试用例                                                     │
│       • 输入：代码或需求描述                                                 │
│       • AI输出：测试用例代码                                                 │
│       • 审核和补充                                                           │
│       • 示例提示词：                                                         │
│         """                                                                  │
│         为以下词法分析器代码生成测试用例：                                   │
│         [Lexer代码]                                                          │
│         要求：                                                               │
│         1. 测试关键字识别                                                    │
│         2. 测试标识符识别                                                    │
│         3. 测试数字字面量识别                                                │
│         4. 测试字符串字面量识别                                              │
│         5. 测试运算符识别                                                    │
│         6. 使用Rust #[test]属性。                                           │
│         """                                                                  │
│                                                                              │
│   2.2 使用AI分析测试覆盖率                                                   │
│       • 识别未覆盖的代码路径                                                 │
│       • 生成补充测试建议                                                     │
│       • 边界条件发现                                                         │
│                                                                              │
│   2.3 实例：SQLRustGo测试                                                    │
│       • 词法分析器测试                                                       │
│       • 语法分析器测试                                                       │
│       • 存储引擎测试                                                         │
│       • 执行引擎测试                                                         │
│                                                                              │
│   Part 3: Rust测试框架（20分钟）                                              │
│   ─────────────────────────                                                  │
│   3.1 #[test] 属性                                                           │
│       • 测试函数定义                                                         │
│       • 测试命名规范                                                         │
│                                                                              │
│   3.2 assert! 宏系列                                                         │
│       • assert!(expr)                                                        │
│       • assert_eq!(left, right)                                              │
│       • assert_ne!(left, right)                                              │
│       • 自定义错误消息                                                       │
│                                                                              │
│   3.3 测试组织                                                               │
│       • 单元测试（#[cfg(test)]）                                             │
│       • 集成测试（tests/目录）                                               │
│       • 文档测试（doc tests）                                                │
│                                                                              │
│   3.4 测试覆盖率工具                                                         │
│       • cargo-tarpaulin                                                      │
│       • cargo-llvm-cov                                                       │
│       • 覆盖率报告                                                           │
│                                                                              │
│   Part 4: Alpha版本验收（20分钟）                                             │
│   ─────────────────────────────                                              │
│   4.1 Alpha版本定义                                                          │
│       • 功能完整性                                                           │
│       • 可运行                                                               │
│       • 有测试                                                               │
│       • 有文档                                                               │
│                                                                              │
│   4.2 功能验收标准                                                           │
│       • SQL解析：支持SELECT/INSERT/UPDATE/DELETE                             │
│       • 存储引擎：支持数据读写                                               │
│       • 执行引擎：支持基本查询执行                                           │
│                                                                              │
│   4.3 质量门禁                                                               │
│       ┌─────────────────────────────────────────────────────────────┐        │
│       │ 检查项           │ 命令                          │ 状态要求 │        │
│       ├─────────────────────────────────────────────────────────────┤        │
│       │ 编译             │ cargo build                   │ 通过     │        │
│       │ 测试             │ cargo test                    │ 全部通过 │        │
│       │ Clippy           │ cargo clippy                  │ 无警告   │        │
│       │ 格式化           │ cargo fmt --check             │ 通过     │        │
│       │ 覆盖率           │ cargo tarpaulin               │ ≥ 70%    │        │
│       └─────────────────────────────────────────────────────────────┘        │
│                                                                              │
│   4.4 Alpha版本发布                                                          │
│       • 创建版本标签                                                         │
│       • 编写Release Notes                                                    │
│       • 发布公告                                                             │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 核心知识点

1. **测试驱动开发**
   - Red-Green-Refactor循环
   - 测试先行的好处
   - TDD实践技巧

2. **AI辅助测试**
   - 测试用例生成
   - 覆盖率分析
   - 边界条件发现

3. **Rust测试框架**
   - #[test]属性
   - assert!宏
   - 测试组织
   - 覆盖率工具

4. **Alpha版本验收**
   - 功能验收标准
   - 质量门禁
   - 发布流程

### 课堂互动

- 练习：使用AI生成测试用例
- 练习：运行测试并查看覆盖率
- 讨论：测试越多越好吗？

### 课后作业

1. 补充单元测试
2. 提高测试覆盖率至70%+
3. 运行所有质量检查
4. 完成Alpha版本

---

## 上半学期总结

### 知识点回顾

| 周次 | 理论知识 | 实践技能 | 项目产出 |
|------|----------|----------|----------|
| 1 | 软件工程发展历史、Greenfield/Brownfield、AI局限性 | 环境搭建 | 开发环境 |
| 2 | 结构化设计、UML概述、用例图 | PlantUML使用 | 用例图文档 |
| 3 | 面向对象设计、SOLID原则、类图 | 类图绘制 | 类图文档 |
| 4 | 顺序图、状态图、架构图、快速原型法 | UML综合实践 | 设计文档 |
| 5 | AI辅助需求分析、提示词工程 | 提示词设计 | 设计文档 |
| 6 | 词法分析、语法分析、AI辅助编码 | 解析器实现 | 解析器模块 |
| 7 | 存储引擎、数据持久化、AI辅助编码 | 存储引擎实现 | 存储模块 |
| 8 | TDD、AI辅助测试、Alpha版本验收 | 测试编写 | Alpha版本 |

### 能力培养目标

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        上半学期能力培养                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   工程思维                                                                   │
│   ────────                                                                   │
│   • 理解软件工程的本质和发展历程                                             │
│   • 理解Greenfield和Brownfield项目的差异                                     │
│   • 掌握结构化设计和面向对象设计方法                                         │
│   • 理解快速原型法的软件工程过程                                             │
│                                                                              │
│   UML建模能力                                                                │
│   ──────────                                                                 │
│   • 掌握用例图、类图、顺序图、状态图、架构图                                  │
│   • 能够使用PlantUML进行文本化建模                                           │
│   • 能够使用AI辅助UML绘图                                                    │
│   • 能够编写规范的设计文档                                                   │
│                                                                              │
│   AI应用能力                                                                 │
│   ──────────                                                                 │
│   • 理解AI Coding的能力边界和局限性                                          │
│   • 掌握提示词工程基础                                                       │
│   • 能够使用AI工具辅助设计和编码                                             │
│   • 能够审查和优化AI生成的代码                                               │
│                                                                              │
│   开发能力                                                                   │
│   ────────                                                                   │
│   • 能够实现词法分析器和语法分析器                                           │
│   • 能够实现存储引擎核心模块                                                 │
│   • 能够编写规范的测试用例                                                   │
│   • 能够完成Alpha版本发布                                                    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

**制定时间**: 2026-02-22
**更新时间**: 2026-03-01
**版本**: v3.0（重新设计：添加UML建模、结构化设计、面向对象设计内容）
